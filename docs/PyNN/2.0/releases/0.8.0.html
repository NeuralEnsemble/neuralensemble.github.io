
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>PyNN 0.8.0 release notes &#8212; PyNN 2.0.0.alpha.1 documentation</title>
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.0.0.alpha.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../_static/pyNN_icon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PyNN 2.0.0.alpha.1 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="pynn-0-8-0-release-notes">
<h1>PyNN 0.8.0 release notes<a class="headerlink" href="#pynn-0-8-0-release-notes" title="Permalink to this headline">¶</a></h1>
<p>October 5th 2015</p>
<p>Welcome to the final release of PyNN 0.8.0!</p>
<p>For PyNN 0.8 we have taken the opportunity to make significant, backward-incompatible
changes to the API. The aim was fourfold:</p>
<blockquote>
<div><ul class="simple">
<li>to simplify the API, making it more consistent and easier to remember;</li>
<li>to make the API more powerful, so more complex models can be expressed with less code;</li>
<li>to allow a number of internal simplifications so it is easier for new developers to contribute;</li>
<li>to prepare for planned future extensions, notably support for multi-compartmental models.</li>
</ul>
</div></blockquote>
<p>We summarize here the main changes between versions 0.7 and 0.8 of the API.</p>
<div class="section" id="creating-populations">
<h2>Creating populations<a class="headerlink" href="#creating-populations" title="Permalink to this headline">¶</a></h2>
<p>In previous versions of PyNN, the <code class="xref py py-class docutils literal"><span class="pre">Population</span></code> constructor was called
with the population size, a <code class="xref py py-class docutils literal"><span class="pre">BaseCellType</span></code> sub-class such as
<code class="xref py py-class docutils literal"><span class="pre">IF_cond_exp</span></code> and a dictionary of parameter values. For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="n">Population</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="n">IF_cond_exp</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;tau_m&#39;</span><span class="p">:</span> <span class="mf">12.0</span><span class="p">,</span> <span class="s1">&#39;cm&#39;</span><span class="p">:</span> <span class="mf">0.8</span><span class="p">})</span>  <span class="c1"># PyNN 0.7</span>
</pre></div>
</div>
<p>This dictionary was passed to the cell-type class constructor within the
<code class="xref py py-class docutils literal"><span class="pre">Population</span></code> constructor to create a cell-type instance.</p>
<p>The reason for doing this was that in early versions of PyNN, use of native
NEST models was supported by passing a string, the model name, as the cell-type
argument. Since PyNN 0.7, however, native models have been supported with the
<code class="xref py py-class docutils literal"><span class="pre">NativeCellType</span></code> class, and passing a string is no longer allowed.</p>
<p>It makes more sense, therefore, for the cell-type instance to be created by the
user, and to pass a cell-type instance, rather than a cell-type class, to the
<code class="xref py py-class docutils literal"><span class="pre">Population</span></code> constructor.</p>
<p>There is also a second change: specification of parameters for cell-type classes
is now done via keyword arguments rather than a single parameter dictionary.
This is for consistency with current sources and synaptic plasticity models,
which already use keyword arguments.</p>
<p>The example above should be rewritten as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="n">Population</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="n">IF_cond_exp</span><span class="p">(</span><span class="n">tau_m</span><span class="o">=</span><span class="mf">12.0</span><span class="p">,</span> <span class="n">cm</span><span class="o">=</span><span class="mf">0.8</span><span class="p">))</span>  <span class="c1"># PyNN 0.8</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="n">Population</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="n">IF_cond_exp</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;tau_m&#39;</span><span class="p">:</span> <span class="mf">12.0</span><span class="p">,</span> <span class="s1">&#39;cm&#39;</span><span class="p">:</span> <span class="mf">0.8</span><span class="p">}))</span>  <span class="c1"># PyNN 0.8</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">cell_type</span> <span class="o">=</span> <span class="n">IF_cond_exp</span><span class="p">(</span><span class="n">tau_m</span><span class="o">=</span><span class="mf">12.0</span><span class="p">,</span> <span class="n">cm</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>   <span class="c1"># PyNN 0.8</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">Population</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="n">cell_type</span><span class="p">)</span>
</pre></div>
</div>
<p>The first form, with a separate parameter dictionary, is still supported for
the time being, but is deprecated and may be removed in future versions.</p>
</div>
<div class="section" id="specifying-heterogeneous-parameter-values">
<h2>Specifying heterogeneous parameter values<a class="headerlink" href="#specifying-heterogeneous-parameter-values" title="Permalink to this headline">¶</a></h2>
<p>In previous versions of PyNN, the <code class="xref py py-class docutils literal"><span class="pre">Population</span></code> constructor supported
setting parameters to either homogeneous values (all cells in the population
have the same value) or random values. After construction, it was possible to
change parameters using the <code class="xref py py-meth docutils literal"><span class="pre">Population.set()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">Population.tset()</span></code>
(for <em>topographic</em> set - parameters were set by using an array of the same
size as the population) and <code class="xref py py-meth docutils literal"><span class="pre">Population.rset()</span></code> (for <em>random</em> set) methods.</p>
<p>In PyNN 0.8, setting parameters is simpler and more consistent, in that both
when constructing a cell type for use in the <code class="xref py py-class docutils literal"><span class="pre">Population</span></code> constructor
(see above) and in the <code class="xref py py-meth docutils literal"><span class="pre">Population.set()</span></code> method, parameter values can be
any of the following:</p>
<blockquote>
<div><ul class="simple">
<li>a single number - sets the same value for all cells in the <code class="xref py py-class docutils literal"><span class="pre">Population</span></code>;</li>
<li>a <code class="xref py py-class docutils literal"><span class="pre">RandomDistribution</span></code> object - for each cell, sets a different
random value drawn from the distribution;</li>
<li>a list or 1D NumPy array of the same size as the <code class="xref py py-class docutils literal"><span class="pre">Population</span></code>;</li>
<li>a function that takes a single integer argument; this function will be
called with the index of every cell in the <code class="xref py py-class docutils literal"><span class="pre">Population</span></code> to return
the parameter value for that cell.</li>
</ul>
</div></blockquote>
<p>See <a class="reference internal" href="../parameters.html"><span class="doc">Model parameters and initial values</span></a> for more details and examples.</p>
<p>The call signature of the <code class="xref py py-meth docutils literal"><span class="pre">Population.set()</span></code> method has also been changed;
now parameters should be specified as keyword arguments. For example, instead
of:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">p</span><span class="o">.</span><span class="n">set</span><span class="p">({</span><span class="s2">&quot;tau_m&quot;</span><span class="p">:</span> <span class="mf">20.0</span><span class="p">})</span>  <span class="c1"># PyNN 0.7</span>
</pre></div>
</div>
<p>use:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">p</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">tau_m</span><span class="o">=</span><span class="mf">20.0</span><span class="p">)</span>  <span class="c1"># PyNN 0.8</span>
</pre></div>
</div>
<p>and instead of:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">p</span><span class="o">.</span><span class="n">set</span><span class="p">({</span><span class="s2">&quot;tau_m&quot;</span><span class="p">:</span> <span class="mf">20.0</span><span class="p">,</span> <span class="s2">&quot;v_rest&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">65</span><span class="p">})</span>  <span class="c1"># PyNN 0.7</span>
</pre></div>
</div>
<p>use:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">p</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">tau_m</span><span class="o">=</span><span class="mf">20.0</span><span class="p">,</span> <span class="n">v_rest</span><span class="o">=-</span><span class="mi">65</span><span class="p">)</span>  <span class="c1"># PyNN 0.8</span>
</pre></div>
</div>
<p>Now that <code class="xref py py-meth docutils literal"><span class="pre">Population.set()</span></code> accepts random distributions and arrays as
arguments, the <code class="xref py py-meth docutils literal"><span class="pre">Population.tset()</span></code> and <code class="xref py py-meth docutils literal"><span class="pre">Population.rset()</span></code> methods are
superfluous. As of version 0.8, their use is deprecated and they will
be removed in the next version of PyNN. Their use can be replaced as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">p</span><span class="o">.</span><span class="n">tset</span><span class="p">(</span><span class="s2">&quot;i_offset&quot;</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span>  <span class="c1"># PyNN 0.7</span>
<span class="n">p</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">i_offset</span><span class="o">=</span><span class="n">arr</span><span class="p">)</span>      <span class="c1"># PyNN 0.8</span>

<span class="n">p</span><span class="o">.</span><span class="n">rset</span><span class="p">(</span><span class="s2">&quot;tau_m&quot;</span><span class="p">,</span> <span class="n">rand_distr</span><span class="p">)</span>  <span class="c1"># PyNN 0.7</span>
<span class="n">p</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">tau_m</span><span class="o">=</span><span class="n">rand_distr</span><span class="p">)</span>      <span class="c1"># PyNN 0.8</span>
</pre></div>
</div>
<div class="section" id="setting-spike-times">
<h3>Setting spike times<a class="headerlink" href="#setting-spike-times" title="Permalink to this headline">¶</a></h3>
<p>Where a single parameter value is already an array, e.g. spike times, this
should be wrapped by a <code class="xref py py-class docutils literal"><span class="pre">Sequence</span></code> object. For example, to generate
a different Poisson spike train for every neuron in a population of
<code class="xref py py-class docutils literal"><span class="pre">SpikeSourceArray</span></code>s:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">generate_spike_times</span><span class="p">(</span><span class="n">i_range</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">Sequence</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">exponential</span><span class="p">(</span><span class="mf">10.0</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">i_range</span><span class="p">]</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">Population</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">SpikeSourceArray</span><span class="p">(</span><span class="n">spike_times</span><span class="o">=</span><span class="n">generate_spike_times</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="standardization-of-random-distributions">
<h3>Standardization of random distributions<a class="headerlink" href="#standardization-of-random-distributions" title="Permalink to this headline">¶</a></h3>
<p>Since its earliest versions PyNN has supported swapping in and out different random number
generators, but until now there has been no standardization of these RNGs;
for example the <a class="reference external" href="https://www.gnu.org/software/gsl/manual/html_node/Random-Number-Generation.html">GSL</a> random number library uses “gaussian” where <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/routines.random.html">NumPy</a> uses “normal”.
This limited the usefulness of this feature, especially for the <code class="xref py py-class docutils literal"><span class="pre">NativeRNG</span></code> class,
which signals that random number generation should be passed down to the simulator backend
rather than being performed at the Python level.</p>
<p>This has now been fixed. The names of random number distributions and of their parameters
have now been standardized, based for the most part on the nomenclature used by <a class="reference external" href="http://en.wikipedia.org/wiki/List_of_probability_distributions">Wikipedia</a>.
A quick example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyNN.random</span> <span class="kn">import</span> <span class="n">NumpyRNG</span><span class="p">,</span> <span class="n">GSLRNG</span><span class="p">,</span> <span class="n">RandomDistribution</span>

<span class="n">rd1</span> <span class="o">=</span> <span class="n">RandomDistribution</span><span class="p">(</span><span class="s1">&#39;normal&#39;</span> <span class="n">mu</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="n">NumpyRNG</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="mi">922843</span><span class="p">))</span>
<span class="n">rd2</span> <span class="o">=</span> <span class="n">RandomDistribution</span><span class="p">(</span><span class="s1">&#39;normal&#39;</span> <span class="n">mu</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="n">GSLRNG</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="mi">426482</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="recording">
<h2>Recording<a class="headerlink" href="#recording" title="Permalink to this headline">¶</a></h2>
<p>Previous versions of PyNN had three methods for recording from populations of
neurons: <code class="xref py py-meth docutils literal"><span class="pre">record()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">record_v()</span></code> and <code class="xref py py-meth docutils literal"><span class="pre">record_gsyn()</span></code>, for
recording spikes, membrane potentials, and synaptic conductances, respectively.
There was no official way to record any other state variables, for example the
<em>w</em> variable from the adaptive-exponential integrate-and-fire model, or when
using native, non-standard models, although there were workarounds.</p>
<p>In PyNN 0.8, we have replaced these three methods with a single <code class="xref py py-meth docutils literal"><span class="pre">record()</span></code>
method, which takes the variable to record as its first argument, e.g.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">p</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>  <span class="c1"># PyNN 0.7</span>
<span class="n">p</span><span class="o">.</span><span class="n">record_v</span><span class="p">()</span>
<span class="n">p</span><span class="o">.</span><span class="n">record_gsyn</span><span class="p">()</span>
</pre></div>
</div>
<p>becomes:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">p</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="s1">&#39;spikes&#39;</span><span class="p">)</span>  <span class="c1"># PyNN 0.8</span>
<span class="n">p</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">record</span><span class="p">([</span><span class="s1">&#39;gsyn_exc&#39;</span><span class="p">,</span> <span class="s1">&#39;gsyn_inh&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Note that (1) you can now choose to record the excitatory and inhibitory
synaptic conductances separately, (2) you can give a list of variables to
record. For example, you can record all the variables for the
<code class="xref py py-class docutils literal"><span class="pre">EIF_cond_exp_isfa_ista</span></code> model in a single command using:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">p</span><span class="o">.</span><span class="n">record</span><span class="p">([</span><span class="s1">&#39;spikes&#39;</span><span class="p">,</span> <span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;gsyn_exc&#39;</span><span class="p">,</span> <span class="s1">&#39;gsyn_inh&#39;</span><span class="p">])</span>  <span class="c1"># PyNN 0.8</span>
</pre></div>
</div>
<p>Note that the <code class="xref py py-meth docutils literal"><span class="pre">record_v()</span></code> and <code class="xref py py-meth docutils literal"><span class="pre">record_gsyn()</span></code> methods still exist,
but their use is deprecated, and they will be removed in the next version of
PyNN.</p>
<p>A further change is that <code class="xref py py-meth docutils literal"><span class="pre">Population.record()</span></code> has an optional <cite>sampling_interval</cite> argument,
allowing recording at intervals larger than the integration time step.</p>
<p>See <a class="reference internal" href="../recording.html"><span class="doc">Recording spikes and state variables</span></a> for more details.</p>
</div>
<div class="section" id="retrieving-recorded-data">
<h2>Retrieving recorded data<a class="headerlink" href="#retrieving-recorded-data" title="Permalink to this headline">¶</a></h2>
<p>Perhaps the biggest change in PyNN 0.8 is that handling of recorded data,
whether retrieval as Python objects or saving to file, now uses the <a class="reference external" href="http://neuralensemble.org/neo">Neo</a>
package, which provides a common Python object model for neurophysiology data
(whether real or simulated).</p>
<p>Using Neo provides several advantages:</p>
<blockquote>
<div><ul class="simple">
<li>data objects contain essential metadata, such as units, sampling interval, etc.;</li>
<li>data can be saved to any of the file formats supported by Neo, including HDF5 and Matlab files;</li>
<li>it is easier to handle data when running multiple simulations with the same network (calling <code class="xref py py-meth docutils literal"><span class="pre">reset()</span></code> between each one);</li>
<li>it is possible to save multiple signals to a single file;</li>
<li>better interoperability with other Python packages using Neo (for data analysis, etc.).</li>
</ul>
</div></blockquote>
<p>Note that Neo is based on NumPy, and most Neo data objects sub-class the NumPy
<code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code> class, so much of your data handling code should work exactly
the same as before.</p>
<p>See <a class="reference internal" href="../data_handling.html"><span class="doc">Data handling</span></a> for more details.</p>
</div>
<div class="section" id="creating-connections">
<h2>Creating connections<a class="headerlink" href="#creating-connections" title="Permalink to this headline">¶</a></h2>
<p>In previous versions of PyNN, synaptic weights and delays were specified on
creation of the <code class="xref py py-class docutils literal"><span class="pre">Connector</span></code> object. If the synaptic weight had its own
dynamics (whether short-term or spike-timing-dependent plasticity), the
parameters for this were specified on creation of a <code class="xref py py-class docutils literal"><span class="pre">SynapseDynamics</span></code>
object. In other words, specification of synaptic parameters was split across
two different classes.</p>
<p><code class="xref py py-class docutils literal"><span class="pre">SynapseDynamics</span></code> was also rather complex, and could have both a “fast”
(for short-term synaptic depression and facilitation) and “slow” (for long-term
plasticity) component, although most simulator backends did not support
specifying both fast and slow components at the same time.</p>
<p>In PyNN 0.8, all synaptic parameters including weights and delays are given as
arguments to a <code class="xref py py-class docutils literal"><span class="pre">SynapseType</span></code> sub-class such as <code class="xref py py-class docutils literal"><span class="pre">StaticSynapse</span></code> or
<code class="xref py py-class docutils literal"><span class="pre">TsodyksMarkramSynapse</span></code>. For example, instead of:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">prj</span> <span class="o">=</span> <span class="n">Projection</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">AllToAllConnector</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">delays</span><span class="o">=</span><span class="mf">0.5</span><span class="p">))</span>  <span class="c1"># PyNN 0.7</span>
</pre></div>
</div>
<p>you should now write:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">prj</span> <span class="o">=</span> <span class="n">Projection</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">AllToAllConnector</span><span class="p">(),</span> <span class="n">StaticSynapse</span><span class="p">(</span><span class="n">weight</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mf">0.5</span><span class="p">))</span>  <span class="c1"># PyNN 0.8</span>
</pre></div>
</div>
<p>and instead of:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">params</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;U&#39;</span><span class="p">:</span> <span class="mf">0.04</span><span class="p">,</span> <span class="s1">&#39;tau_rec&#39;</span><span class="p">:</span> <span class="mf">100.0</span><span class="p">,</span> <span class="s1">&#39;tau_facil&#39;</span><span class="p">:</span> <span class="mf">1000.0</span><span class="p">}</span>
<span class="n">facilitating</span> <span class="o">=</span> <span class="n">SynapseDynamics</span><span class="p">(</span><span class="n">fast</span><span class="o">=</span><span class="n">TsodyksMarkramMechanism</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">))</span>   <span class="c1"># PyNN 0.7</span>
<span class="n">prj</span> <span class="o">=</span> <span class="n">Projection</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">FixedProbabilityConnector</span><span class="p">(</span><span class="n">p_connect</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="mf">0.01</span><span class="p">),</span>
                 <span class="n">synapse_dynamics</span><span class="o">=</span><span class="n">facilitating</span><span class="p">)</span>
</pre></div>
</div>
<p>the following:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">params</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;U&#39;</span><span class="p">:</span> <span class="mf">0.04</span><span class="p">,</span> <span class="s1">&#39;tau_rec&#39;</span><span class="p">:</span> <span class="mf">100.0</span><span class="p">,</span> <span class="s1">&#39;tau_facil&#39;</span><span class="p">:</span> <span class="mf">1000.0</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="mf">0.01</span><span class="p">}</span>
<span class="n">facilitating</span> <span class="o">=</span> <span class="n">TsodyksMarkramSynapse</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>                          <span class="c1"># PyNN 0.8</span>
<span class="n">prj</span> <span class="o">=</span> <span class="n">Projection</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">FixedProbabilityConnector</span><span class="p">(</span><span class="n">p_connect</span><span class="o">=</span><span class="mf">0.1</span><span class="p">),</span>
                 <span class="n">synapse_type</span><span class="o">=</span><span class="n">facilitating</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that <em>“weights”</em> and <em>“delays”</em> are now <em>“weight”</em> and <em>“delay”</em>. In addition,
the <em>“method”</em> argument to <code class="xref py py-class docutils literal"><span class="pre">Projection</span></code> is now called <em>“connector”</em>,
and the <em>“target”</em> argument is now <em>“receptor_type”</em>. The <em>“rng”</em> argument has
been moved from <code class="xref py py-class docutils literal"><span class="pre">Projection</span></code> to <code class="xref py py-class docutils literal"><span class="pre">Connector</span></code>, and the <em>“space”</em>
argument of <code class="xref py py-class docutils literal"><span class="pre">Connector</span></code> has been moved to <code class="xref py py-class docutils literal"><span class="pre">Projection</span></code>.</p>
<p>The ability to specify both short-term and long-term plasticity for a given
connection type, in a simulator-independent way, has been removed, although in
practice only the NEURON backend supported this. This functionality will be
reintroduced in PyNN 0.9. If you need this in the meantime, a workaround for the
NEURON backend is to use a <code class="xref py py-class docutils literal"><span class="pre">NativeSynapseType</span></code> mechanism - ask on the
<a class="reference external" href="http://groups.google.com/group/neuralensemble">mailing list</a> for guidance.</p>
<p>Finally, the parameterization of STDP models has been modified. The <cite>A_plus</cite> and <cite>A_minus</cite>
parameters have been moved from the weight-dependence components to the
timing-dependence components, since effectively they describe the shape of the
STDP curve independently of how the weight change depends on the current weight.</p>
</div>
<div class="section" id="specifying-heterogeneous-synapse-parameters">
<h2>Specifying heterogeneous synapse parameters<a class="headerlink" href="#specifying-heterogeneous-synapse-parameters" title="Permalink to this headline">¶</a></h2>
<p>As for neuron parameters, synapse parameter values can now be any of the
following:</p>
<blockquote>
<div><ul class="simple">
<li>a single number - sets the same value for all connections in the <code class="xref py py-class docutils literal"><span class="pre">Projection</span></code>;</li>
<li>a <code class="xref py py-class docutils literal"><span class="pre">RandomDistribution</span></code> object - for each connection, sets a different
random value drawn from the distribution;</li>
<li>a list or 1D NumPy array of the same size as the <code class="xref py py-class docutils literal"><span class="pre">Projection</span></code>
(although this is not very useful for random networks, whose size may not
be known in advance);</li>
<li>a function that takes a single float argument; this function will be
called with the <em>distance</em> between the pre- and post-synaptic cell to return
the parameter value for that cell.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="accessing-setting-and-saving-properties-of-synaptic-connections">
<h2>Accessing, setting and saving properties of synaptic connections<a class="headerlink" href="#accessing-setting-and-saving-properties-of-synaptic-connections" title="Permalink to this headline">¶</a></h2>
<p>In older versions of PyNN, the <code class="xref py py-class docutils literal"><span class="pre">Projection</span></code> class had a bunch of methods
for working with synaptic parameters: <code class="xref py py-meth docutils literal"><span class="pre">getWeights()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">setWeights()</span></code>,
<code class="xref py py-meth docutils literal"><span class="pre">randomizeWeights()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">printWeights()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">getDelays()</span></code>,
<code class="xref py py-meth docutils literal"><span class="pre">setDelays()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">randomizeDelays()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">printDelays()</span></code>,
<code class="xref py py-meth docutils literal"><span class="pre">getSynapseDynamics()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">setSynapseDynamics()</span></code>,
<code class="xref py py-meth docutils literal"><span class="pre">randomizeSynapseDynamics()</span></code>, and <code class="xref py py-meth docutils literal"><span class="pre">saveConnections()</span></code>.</p>
<p>These have been replace by three methods: <code class="xref py py-meth docutils literal"><span class="pre">get()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">set()</span></code> and
<code class="xref py py-meth docutils literal"><span class="pre">save()</span></code>. The original methods still exist, but their use is deprecated and
they will be removed in the next version of PyNN. You should update your code
as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">prj</span><span class="o">.</span><span class="n">getWeights</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="s1">&#39;list&#39;</span><span class="p">)</span>                          <span class="c1"># PyNN 0.7</span>
<span class="n">prj</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;weight&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;list&#39;</span><span class="p">,</span> <span class="n">with_address</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>   <span class="c1"># PyNN 0.8</span>

<span class="n">prj</span><span class="o">.</span><span class="n">randomizeDelays</span><span class="p">(</span><span class="n">rand_distr</span><span class="p">)</span>                        <span class="c1"># PyNN 0.7</span>
<span class="n">prj</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="n">rand_distr</span><span class="p">)</span>                              <span class="c1"># PyNN 0.8</span>

<span class="n">prj</span><span class="o">.</span><span class="n">setSynapseDynamics</span><span class="p">(</span><span class="s1">&#39;tau_rec&#39;</span><span class="p">,</span> <span class="mf">50.0</span><span class="p">)</span>                <span class="c1"># PyNN 0.7</span>
<span class="n">prj</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">tau_rec</span><span class="o">=</span><span class="mf">50.0</span><span class="p">)</span>                                  <span class="c1"># PyNN 0.8</span>

<span class="n">prj</span><span class="o">.</span><span class="n">printWeights</span><span class="p">(</span><span class="s1">&#39;exc_weights.txt&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;array&#39;</span><span class="p">)</span>    <span class="c1"># PyNN 0.7</span>
<span class="n">prj</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;weight&#39;</span><span class="p">,</span> <span class="s1">&#39;exc_weights.txt&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;array&#39;</span><span class="p">)</span>  <span class="c1"># PyNN 0.8</span>

<span class="n">prj</span><span class="o">.</span><span class="n">saveConnections</span><span class="p">(</span><span class="s1">&#39;exc_conn.txt&#39;</span><span class="p">)</span>                    <span class="c1"># PyNN 0.7</span>
<span class="n">prj</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;exc_conn.txt&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;list&#39;</span><span class="p">)</span>         <span class="c1"># PyNN 0.8</span>
</pre></div>
</div>
<p>Also note that all three new methods can operate on several parameters at a time:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">weights</span><span class="p">,</span> <span class="n">delays</span> <span class="o">=</span> <span class="n">prj</span><span class="o">.</span><span class="n">getWeights</span><span class="p">(</span><span class="s1">&#39;array&#39;</span><span class="p">),</span> <span class="n">prj</span><span class="o">.</span><span class="n">getDelays</span><span class="p">(</span><span class="s1">&#39;array&#39;</span><span class="p">)</span>  <span class="c1"># PyNN 0.7</span>
<span class="n">weights</span><span class="p">,</span> <span class="n">delays</span> <span class="o">=</span> <span class="n">prj</span><span class="o">.</span><span class="n">get</span><span class="p">([</span><span class="s1">&#39;weight&#39;</span><span class="p">,</span> <span class="s1">&#39;delay&#39;</span><span class="p">],</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;array&#39;</span><span class="p">)</span>     <span class="c1"># PyNN 0.8</span>

<span class="n">prj</span><span class="o">.</span><span class="n">randomizeWeights</span><span class="p">(</span><span class="n">rand_distr</span><span class="p">);</span> <span class="n">prj</span><span class="o">.</span><span class="n">setDelays</span><span class="p">(</span><span class="mf">0.4</span><span class="p">)</span>               <span class="c1"># PyNN 0.7</span>
<span class="n">prj</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">weight</span><span class="o">=</span><span class="n">rand_distr</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>                              <span class="c1"># PyNN 0.8</span>
</pre></div>
</div>
</div>
<div class="section" id="new-and-improved-connectors">
<h2>New and improved connectors<a class="headerlink" href="#new-and-improved-connectors" title="Permalink to this headline">¶</a></h2>
<p>The library of <code class="xref py py-class docutils literal"><span class="pre">Connector</span></code> classes has been extended. The
<code class="xref py py-class docutils literal"><span class="pre">DistanceDependentProbabilityConnector</span></code> (DDPC) has been generalized, resulting
in the <code class="xref py py-class docutils literal"><span class="pre">IndexBasedProbabilityConnector</span></code>, with which the connection
probability can be specified as any function of the indices <em>i</em> and <em>j</em> of the
pre- and post-synaptic neurons within their populations. In addition, the
distance expression for the DDPC can now be a callable object (such as a
function) as well as a string expression.</p>
<p>The <code class="xref py py-class docutils literal"><span class="pre">ArrayConnector</span></code> allows connections to be specified as an explicit
boolean matrix, with shape (<em>m</em>, <em>n</em>) where <em>m</em> is the size of the presynaptic
population and <em>n</em> that of the postsynaptic population.</p>
<p>The <code class="xref py py-class docutils literal"><span class="pre">CloneConnector</span></code> takes the connection
matrix from an existing <code class="xref py py-class docutils literal"><span class="pre">Projection</span></code> and uses it to create a new <code class="xref py py-class docutils literal"><span class="pre">Projection</span></code>,
with the option of changing the weights, delays, receptor type, etc.</p>
<p>The <code class="xref py py-class docutils literal"><span class="pre">FromListConnector</span></code> and <code class="xref py py-class docutils literal"><span class="pre">FromFileConnector</span></code> now support
specifying any synaptic parameter (e.g. parameters of the synaptic plasticity
rule), not just weight and delay.</p>
<p>The <code class="xref py py-class docutils literal"><span class="pre">FixedNumberPostConnector</span></code> now has an option <cite>with_replacement</cite>,
which controls how the post-synaptic population is sampled,
and affects the incidence of multiple connections between pairs of neurons (“multapses”).</p>
<p>We have added a version of <code class="xref py py-class docutils literal"><span class="pre">CSAConnector</span></code> for the NEST backend that passes down the CSA
object to PyNEST’s <code class="xref py py-func docutils literal"><span class="pre">CGConnect()</span></code> function.
This greatly speeds up <code class="xref py py-class docutils literal"><span class="pre">CSAConnector</span></code> with NEST.</p>
</div>
<div class="section" id="simulation-control">
<h2>Simulation control<a class="headerlink" href="#simulation-control" title="Permalink to this headline">¶</a></h2>
<p>Two new functions for advancing a simulation have been added: <code class="xref py py-func docutils literal"><span class="pre">run_for()</span></code>
and <code class="xref py py-func docutils literal"><span class="pre">run_until()</span></code>. <code class="xref py py-func docutils literal"><span class="pre">run_for()</span></code> is just an alias for <code class="xref py py-func docutils literal"><span class="pre">run()</span></code>.
<code class="xref py py-func docutils literal"><span class="pre">run_until()</span></code> allows you to specify the absolute time at which a
simulation should stop, rather than the increment of time. In addition, it is
now possible to specify a call-back function that should be called at
intervals during a run, e.g.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">report_time</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The time is </span><span class="si">%g</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">t</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">t</span> <span class="o">+</span> <span class="mf">100.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">run_until</span><span class="p">(</span><span class="mf">300.0</span><span class="p">,</span> <span class="n">callbacks</span><span class="o">=</span><span class="p">[</span><span class="n">report_time</span><span class="p">])</span>
<span class="go">The time is 0</span>
<span class="go">The time is 100</span>
<span class="go">The time is 200</span>
<span class="go">The time is 300</span>
</pre></div>
</div>
<p>One potential use of this feature is to record synaptic weights during a
simulation with synaptic plasticity.</p>
<p>The default value of the <cite>min_delay</cite> argument to <code class="xref py py-func docutils literal"><span class="pre">setup()</span></code> is now “auto”,
which means that the simulator should calculate the minimal synaptic delay itself.
This change can lead to large speedups for NEST and NEURON code.</p>
</div>
<div class="section" id="simple-plotting">
<h2>Simple plotting<a class="headerlink" href="#simple-plotting" title="Permalink to this headline">¶</a></h2>
<p>We have added a small library to make it simple to produce simple plots of
data recorded from a PyNN simulation. This is not intended for
publication-quality or highly-customized plots, but for basic visualization.</p>
<p>For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyNN.utility.plotting</span> <span class="k">import</span> <span class="n">Figure</span><span class="p">,</span> <span class="n">Panel</span>

<span class="o">...</span>

<span class="n">population</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="s1">&#39;spikes&#39;</span><span class="p">)</span>
<span class="n">population</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">((</span><span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="s1">&#39;gsyn_exc&#39;</span><span class="p">))</span>

<span class="o">...</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">population</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="n">vm</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;v&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">gsyn</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;gsyn_exc&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<span class="n">Figure</span><span class="p">(</span>
    <span class="n">Panel</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s2">&quot;Membrane potential (mV)&quot;</span><span class="p">),</span>
    <span class="n">Panel</span><span class="p">(</span><span class="n">gsyn</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s2">&quot;Synaptic conductance (uS)&quot;</span><span class="p">),</span>
    <span class="n">Panel</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">spiketrains</span><span class="p">,</span> <span class="n">xlabel</span><span class="o">=</span><span class="s2">&quot;Time (ms)&quot;</span><span class="p">,</span> <span class="n">xticks</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;simulation_results.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/release_0.8b1_example1.png"><img alt="Image generated using the Figure and Panel classes from pyNN.utility.plotting" class="align-center" src="../_images/release_0.8b1_example1.png" style="width: 600px;" /></a>
</div>
<div class="section" id="supported-backends">
<h2>Supported backends<a class="headerlink" href="#supported-backends" title="Permalink to this headline">¶</a></h2>
<p>PyNN 0.8.0 is compatible with NEST versions 2.6 to 2.8, NEURON versions 7.3 to 7.4,
and Brian 1.4. Support for Brian 2 is planned for a future release.</p>
<p>Support for the PCSIM simulator has been dropped since the simulator appears to be
no longer actively developed.</p>
<p>The default precision for the <a class="reference external" href="http://www.nest-initiative.org/">NEST</a> backend has been changed to “off_grid”.
This reflects the PyNN philosophy that defaults should prioritize accuracy and
compatibility over performance. (We think performance is very important, it’s
just that any decision to risk compromising accuracy or interoperability should
be made deliberately by the end user.)</p>
<p>The Izhikevich neuron model is now available for all backends.</p>
</div>
<div class="section" id="python-compatibility">
<h2>Python compatibility<a class="headerlink" href="#python-compatibility" title="Permalink to this headline">¶</a></h2>
<p>Support for Python 3 has been added (versions 3.3+). Support for Python versions 2.5 and earlier
has been dropped.</p>
</div>
<div class="section" id="changes-for-developers">
<h2>Changes for developers<a class="headerlink" href="#changes-for-developers" title="Permalink to this headline">¶</a></h2>
<p>Other than the internal refactoring, the main change for developers is that we have
switched from Subversion to Git.
PyNN development now takes place at <a class="reference external" href="https://github.com/NeuralEnsemble/PyNN/">https://github.com/NeuralEnsemble/PyNN/</a>
We are now taking advantage of the integration of GitHub with <a class="reference external" href="https://travis-ci.org/NeuralEnsemble/PyNN">TravisCI</a>, to
automatically run the test suite whenever changes are pushed to GitHub.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/pyNN_logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">PyNN 0.8.0 release notes</a><ul>
<li><a class="reference internal" href="#creating-populations">Creating populations</a></li>
<li><a class="reference internal" href="#specifying-heterogeneous-parameter-values">Specifying heterogeneous parameter values</a><ul>
<li><a class="reference internal" href="#setting-spike-times">Setting spike times</a></li>
<li><a class="reference internal" href="#standardization-of-random-distributions">Standardization of random distributions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#recording">Recording</a></li>
<li><a class="reference internal" href="#retrieving-recorded-data">Retrieving recorded data</a></li>
<li><a class="reference internal" href="#creating-connections">Creating connections</a></li>
<li><a class="reference internal" href="#specifying-heterogeneous-synapse-parameters">Specifying heterogeneous synapse parameters</a></li>
<li><a class="reference internal" href="#accessing-setting-and-saving-properties-of-synaptic-connections">Accessing, setting and saving properties of synaptic connections</a></li>
<li><a class="reference internal" href="#new-and-improved-connectors">New and improved connectors</a></li>
<li><a class="reference internal" href="#simulation-control">Simulation control</a></li>
<li><a class="reference internal" href="#simple-plotting">Simple plotting</a></li>
<li><a class="reference internal" href="#supported-backends">Supported backends</a></li>
<li><a class="reference internal" href="#python-compatibility">Python compatibility</a></li>
<li><a class="reference internal" href="#changes-for-developers">Changes for developers</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/releases/0.8.0.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PyNN 2.0.0.alpha.1 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2006-2017, the PyNN community.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.3.
    </div>
  </body>
</html>