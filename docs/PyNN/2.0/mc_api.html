
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Multicompartmental modelling with PyNN: extensions to the API &#8212; PyNN 2.0.0.alpha.1 documentation</title>
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.0.0.alpha.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="shortcut icon" href="_static/pyNN_icon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Multicompartmental modelling with PyNN: examples" href="mc_examples.html" />
    <link rel="prev" title="Multicompartmental modelling with PyNN: design goals" href="mc_aims.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="mc_examples.html" title="Multicompartmental modelling with PyNN: examples"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="mc_aims.html" title="Multicompartmental modelling with PyNN: design goals"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">PyNN 2.0.0.alpha.1 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="multicompartmental-modelling-with-pynn-extensions-to-the-api">
<h1>Multicompartmental modelling with PyNN: extensions to the API<a class="headerlink" href="#multicompartmental-modelling-with-pynn-extensions-to-the-api" title="Permalink to this headline">¶</a></h1>
<div class="section" id="cell-types">
<h2>Cell types<a class="headerlink" href="#cell-types" title="Permalink to this headline">¶</a></h2>
<p>A <code class="xref py py-class docutils literal"><span class="pre">Population</span></code> in PyNN is a group of neurons all of the same type,
specified by a sub-class of <code class="xref py py-class docutils literal"><span class="pre">CellType</span></code>, such as <code class="xref py py-class docutils literal"><span class="pre">IF_cond_exp</span></code>.
The cell type class defines the equations of the model, but not the model parameters:
these are specified when an instance of the cell type is created,
and may be different for different neurons within the <code class="xref py py-class docutils literal"><span class="pre">Population</span></code>.
For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">cell_type</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">IF_cond_exp</span><span class="p">(</span><span class="n">tau_m</span><span class="o">=</span><span class="n">RandomDistribution</span><span class="p">(</span><span class="s1">&#39;normal&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mf">15.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)),</span>
                            <span class="n">cm</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
                            <span class="n">v_thresh</span><span class="o">=</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="o">-</span><span class="mf">50.0</span> <span class="o">+</span> <span class="mf">0.01</span><span class="o">*</span><span class="n">i</span><span class="p">)</span>
<span class="n">population</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">Population</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">cell_type</span><span class="p">)</span>
</pre></div>
</div>
<p>Here we create 100 neurons.
They all have the same equations (integrate-and-fire model),
and they all have the same value for the membrane capacitance (<cite>cm</cite> parameter),
but each neuron has a different membrane potential (parameter <cite>tau_m</cite>), drawn from a normal distribution,
and each neuron has a different firing threshold (parameter <cite>v_thresh</cite>,
determined by a function of its position within the population).</p>
<p>The most common way to specify cell types in earlier versions of PyNN is through choosing a model from the PyNN
standard library.
These are models that have the same behaviour in all supported simulators.
The standard library approach is not applicable to morphologically and biophysically-detailed neuron models,
as the number of possible combinations of morphologies, ion-channel models and synapse models is infinite.</p>
<p>The approach we are proposing for PyNN 2.0 therefore is to compose cell types from sub-components, e.g.:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">pyramidal_cell_class</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">MultiCompartmentNeuron</span>  <span class="c1"># standard base class for multi-compartment neurons</span>
<span class="n">pyramidal_cell_class</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;PyramidalNeuron&quot;</span>
<span class="n">pyramidal_cell_class</span><span class="o">.</span><span class="n">ion_channels</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;pas&#39;</span><span class="p">:</span> <span class="n">sim</span><span class="o">.</span><span class="n">PassiveLeak</span><span class="p">,</span>  <span class="c1"># standard library of ion channel models</span>
                                     <span class="s1">&#39;na&#39;</span><span class="p">:</span> <span class="n">sim</span><span class="o">.</span><span class="n">NaChannel</span><span class="p">,</span>
                                     <span class="s1">&#39;kdr&#39;</span><span class="p">:</span> <span class="n">sim</span><span class="o">.</span><span class="n">KdrChannel</span><span class="p">}</span>
<span class="n">pyramidal_cell_class</span><span class="o">.</span><span class="n">post_synaptic_entities</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;AMPA&#39;</span><span class="p">:</span> <span class="n">sim</span><span class="o">.</span><span class="n">CondExpPostSynapticResponse</span><span class="p">,</span>  <span class="c1"># standard library of synapse models</span>
                                               <span class="s1">&#39;GABA_A&#39;</span><span class="p">:</span> <span class="n">sim</span><span class="o">.</span><span class="n">CondExpPostSynapticResponse</span><span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">an alternative would be to use a factory function, but the resulting class would be effectively the same</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">here we are using ion channel and synapse models from a standard library, but we also plan to support
LEMS (NeuroML) and NineML model specifications for this.</p>
</div>
</div>
<div class="section" id="parameterization">
<h2>Parameterization<a class="headerlink" href="#parameterization" title="Permalink to this headline">¶</a></h2>
<p>When it come to instantiating such a cell type in order to create a population, three extensions are needed when compared
to the point-neuron case:</p>
<dl class="docutils">
<dt><strong>Hierarchical parameter sets</strong></dt>
<dd>Ion channel parameters should be in a separate dictionary nested inside the main parameter dictionary)</dd>
<dt><strong>More complex parameter types</strong></dt>
<dd>For the standard library of point neurons, most of the parameters are floats, with <code class="xref py py-class docutils literal"><span class="pre">Sequence</span></code> being the only special case.
For morphologically-detailed neurons, one of the parameters should be a representation of an entire morphology, since
different neurons within a population can be expected to have different morphologies.</dd>
<dt><strong>Spatial parameterization within neuron morphologies</strong></dt>
<dd>Point neurons may have parameter values that depend on the position of the neuron in space.
Neurons with axons and dendrites may have parameters whose value depends on location <em>within</em> a single neuron.</dd>
</dl>
<p>In the “mc” branch of PyNN, and in the underlying “lazyarray” package,
we have extended the parameter set machinery to handle hierarchical parameters,
and parameters of arbitrary type.</p>
<p>Spatial parameterization is described in the next section.</p>
</div>
<div class="section" id="morphologies">
<h2>Morphologies<a class="headerlink" href="#morphologies" title="Permalink to this headline">¶</a></h2>
<p>A number of existing Python tools for handling neuronal morphologies already exist
(e.g. <a class="reference external" href="https://libneuroml.readthedocs.io/en/latest/">libNeuroML</a>, <a class="reference external" href="http://briansimulator.org">Brian 2</a>, <a class="reference external" href="http://neurom.readthedocs.io/en/stable/">NeuroM</a>, <a class="reference external" href="https://github.com/btorb/btmorph_v2">btmorph</a>)
In the interest of integrating with other open-source simulation tools and standards wherever possible,
rather than reinventing the wheel (see <a class="reference internal" href="mc_aims.html"><span class="doc">Multicompartmental modelling with PyNN: design goals</span></a>), we would like to make use of these tools within PyNN,
and give users a choice of tools where there is overlap.</p>
<p>Our proposed implementation of this is to define an interface through a parent <code class="xref py py-class docutils literal"><span class="pre">Morphology</span></code>,
which can be sub-classed for the different Python representations of neuronal morphology,
e.g. <code class="xref py py-class docutils literal"><span class="pre">NeuroMLMorphology</span></code>, <code class="xref py py-class docutils literal"><span class="pre">BrianMorphology</span></code>.</p>
<p>Once we have a standard interface for working with morphologies, we can define tools for spatial parameterization,
and, more generally, for specifying points and regions within the neurites, in a format-independent way.</p>
<p>This feature is at an early stage of elaboration.</p>
<p>The general principle is to present an interface to the user that treats the neuron as a continuous
tree structure, and hides details of the spatial discretization, while mapping points and regions defined by the user
to the particular section/segment used internally by the simulator.</p>
<div class="section" id="selecting-points-and-regions">
<h3>Selecting points and regions<a class="headerlink" href="#selecting-points-and-regions" title="Permalink to this headline">¶</a></h3>
<p>For simple morphologies, each section/segment/compartment of the neuron can be given an explicit label.
Where we wish to distinguish a point <em>within</em> a section, we can add a <cite>fraction_along</cite> parameter.
By default, a label is taken to refer to the centre of a section.</p>
<p>Thus, for example, if we specify a two-compartment neuron using NeuroML:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">neuroml</span> <span class="kn">import</span> <span class="n">Segment</span><span class="p">,</span> <span class="n">Point3DWithDiam</span> <span class="k">as</span> <span class="n">P</span>
<span class="kn">from</span> <span class="nn">pyNN.morphology</span> <span class="kn">import</span> <span class="n">NeuroMLMorphology</span>

<span class="n">soma</span> <span class="o">=</span> <span class="n">Segment</span><span class="p">(</span><span class="n">proximal</span><span class="o">=</span><span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">diameter</span><span class="o">=</span><span class="mf">18.8</span><span class="p">),</span>
               <span class="n">distal</span><span class="o">=</span><span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mf">18.8</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">diameter</span><span class="o">=</span><span class="mf">18.8</span><span class="p">),</span>
               <span class="n">name</span><span class="o">=</span><span class="s2">&quot;soma&quot;</span><span class="p">)</span>
<span class="n">dend</span> <span class="o">=</span> <span class="n">Segment</span><span class="p">(</span><span class="n">proximal</span><span class="o">=</span><span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">diameter</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span>
               <span class="n">distal</span><span class="o">=</span><span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="o">=-</span><span class="mi">500</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">diameter</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span>
               <span class="n">name</span><span class="o">=</span><span class="s2">&quot;dendrite&quot;</span><span class="p">,</span>
               <span class="n">parent</span><span class="o">=</span><span class="n">soma</span><span class="p">)</span>

<span class="n">cell_type</span> <span class="o">=</span> <span class="n">cell_class</span><span class="p">(</span><span class="n">morphology</span><span class="o">=</span><span class="n">NeuroMLMorphology</span><span class="p">(</span><span class="n">segments</span><span class="o">=</span><span class="p">(</span><span class="n">soma</span><span class="p">,</span> <span class="n">dend</span><span class="p">)),</span>
                       <span class="o">...</span><span class="n">other</span> <span class="n">parameters</span><span class="o">...</span><span class="p">)</span>
<span class="n">cells</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">Population</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">cell_type</span><span class="p">)</span>
</pre></div>
</div>
<p>Then we can, for example, specify where to inject a current using the segment labels:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">step_current</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">DCSource</span><span class="p">(</span><span class="n">amplitude</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mf">50.0</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="mf">150.0</span><span class="p">)</span>
<span class="n">step_current</span><span class="o">.</span><span class="n">inject_into</span><span class="p">(</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span> <span class="n">location</span><span class="o">=</span><span class="s2">&quot;soma&quot;</span><span class="p">)</span>
<span class="n">step_current</span><span class="o">.</span><span class="n">inject_into</span><span class="p">(</span><span class="n">cells</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">location</span><span class="o">=</span><span class="s2">&quot;dendrite&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>or, similarly, where to record the membrane voltage:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">cells</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="n">locations</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;soma&#39;</span><span class="p">,</span> <span class="s1">&#39;dendrite&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>For detailed morphologies it is less easy/useful to address/label specific sections,
with the exception of the soma and perhaps the axon initial segment.
We create such a morphology using, for example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyNN.morphology</span> <span class="kn">import</span> <span class="n">load_morphology</span>

<span class="n">pyr_morph</span> <span class="o">=</span> <span class="n">load_morphology</span><span class="p">(</span><span class="s2">&quot;oi15rpy4-1.CNG.swc&quot;</span><span class="p">)</span>
<span class="n">pyramidal_cell_class</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">MultiCompartmentNeuron</span>
<span class="o">...</span>

<span class="n">pyramidal_cell_type</span> <span class="o">=</span> <span class="n">pyramidal_cell_class</span><span class="p">(</span><span class="n">morphology</span><span class="o">=</span><span class="n">pyr_morph</span><span class="p">,</span>
                                           <span class="o">...</span><span class="n">other</span> <span class="n">parameters</span><span class="o">...</span><span class="p">)</span>
<span class="n">pyramidal_cells</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">Population</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">pyramidal_cell_type</span><span class="p">)</span>
</pre></div>
</div>
<p>In this scenario, we wish to express locations such as
“a point 400 µm from the soma along the apical dendrites”
(where we don’t particularly care which branch of the apical dendrites we inject the current into).
We propose an API something like:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">step_current</span><span class="o">.</span><span class="n">inject_into</span><span class="p">(</span><span class="n">cells</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="n">sample</span><span class="p">(</span><span class="n">apical_dendrites</span><span class="p">(</span><span class="n">distance_along</span><span class="o">=</span><span class="mf">400.0</span><span class="p">)))</span>
</pre></div>
</div>
<p>where <code class="xref py py-func docutils literal"><span class="pre">sample()</span></code> and <code class="xref py py-func docutils literal"><span class="pre">apical_dendrites()</span></code> are Python callables (currently implemented as subclasses of a
base class <code class="xref py py-class docutils literal"><span class="pre">MorphologyFilter</span></code>, but could be functions) that can be chained together as shown.
Other filters could be <code class="xref py py-func docutils literal"><span class="pre">basal_dendrites()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">dendrites()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">axon()</span></code>,
<code class="xref py py-func docutils literal"><span class="pre">after_branch_point()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">longest_dendrite()</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">identifying apical and basal dendrites depends on the morphology description file providing these labels.
This is the case for SWC files, and it is also supported by NeuroML.
(todo: check whether Neurolucida files contain this information)</p>
</div>
<p>Some of the same filters can be used in specifying regions of the dendritic tree in which to place ion channels
or synapses, for example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">pyramidal_cell</span> <span class="o">=</span> <span class="n">pyramidal_cell_class</span><span class="p">(</span>
                    <span class="n">morphology</span><span class="o">=</span><span class="n">pyr_morph</span><span class="p">,</span>
                    <span class="n">pas</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;conductance_density&quot;</span><span class="p">:</span> <span class="n">uniform</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="mf">0.0003</span><span class="p">),</span>
                         <span class="s2">&quot;e_rev&quot;</span><span class="p">:</span><span class="o">-</span><span class="mf">54.3</span><span class="p">},</span>
                    <span class="n">na</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;conductance_density&quot;</span><span class="p">:</span> <span class="n">uniform</span><span class="p">(</span><span class="s1">&#39;soma&#39;</span><span class="p">,</span> <span class="mf">0.120</span><span class="p">),</span>
                           <span class="s2">&quot;e_rev&quot;</span><span class="p">:</span> <span class="mf">50.0</span><span class="p">},</span>
                    <span class="n">kdr</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;conductance_density&quot;</span><span class="p">:</span> <span class="n">by_distance</span><span class="p">(</span><span class="n">apical_dendrites</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="mf">0.05</span><span class="o">*</span><span class="n">d</span><span class="o">/</span><span class="mf">200.0</span><span class="p">),</span>
                         <span class="s2">&quot;e_rev&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mf">77.0</span><span class="p">},</span>
                    <span class="n">cm</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                    <span class="n">Ra</span><span class="o">=</span><span class="mf">500.0</span><span class="p">,</span>
                    <span class="n">AMPA</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;density&quot;</span><span class="p">:</span> <span class="n">uniform</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">),</span>  <span class="c1"># number per µm</span>
                          <span class="s2">&quot;e_rev&quot;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
                          <span class="s2">&quot;tau_syn&quot;</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">},</span>
                    <span class="n">GABA_A</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;density&quot;</span><span class="p">:</span> <span class="n">by_distance</span><span class="p">(</span><span class="n">dendrites</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="mf">0.05</span> <span class="o">*</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="mf">50.0</span><span class="p">)),</span>  <span class="c1"># number per µm</span>
                            <span class="s2">&quot;e_rev&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mf">70.0</span><span class="p">,</span>
                            <span class="s2">&quot;tau_syn&quot;</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">})</span>
</pre></div>
</div>
<p>Here we combine morphology filters like <code class="xref py py-func docutils literal"><span class="pre">apical_dendrites()</span></code> with spatial distribution functions like
<code class="xref py py-func docutils literal"><span class="pre">uniform()</span></code> and <code class="xref py py-func docutils literal"><span class="pre">by_distance()</span></code> (all defined in the module <code class="xref py py-mod docutils literal"><span class="pre">pyNN.morphology</span></code>).</p>
<p>We can also record state regions from entire regions of the neurites, e.g.:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">pyramidal_cells</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="n">locations</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;dend&quot;</span><span class="p">:</span> <span class="n">apical_dendrites</span><span class="p">()})</span>
</pre></div>
</div>
<p>where <cite>“dend”</cite> is a label that will be given to the <code class="xref py py-class docutils literal"><span class="pre">AnalogSignal</span></code> containing the membrane potential recorded
from the apical dendrites (one channel per section/segment/compartment per neuron).</p>
</div>
</div>
<div class="section" id="projections">
<h2>Projections<a class="headerlink" href="#projections" title="Permalink to this headline">¶</a></h2>
<p>In making synaptic connections onto neurons with detailed morphologies,
we have to consider not only which post-synaptic neuron to connect to and which synapse <em>type</em> to use,
but also in which location within the morphology the synapse should be.</p>
<p>There are two possible strategies when placing the post-synaptic component of synapses on neurons:</p>
<ol class="arabic simple">
<li>place the post-synaptic mechanisms when creating the population (parameterized in the cell type),
then when making connections select from this pre-existing list;</li>
<li>place the post-synaptic mechanisms at the moment of creating connections.</li>
</ol>
<p>Both strategies are in fairly widespread use, so it would be worthwhile to support both approaches in PyNN.</p>
<p>For Strategy 1, we specify the synaptic density when creating the cell type,
as seen in the “pyramidal_cell” example above.
It should also be possible to specify the placement of individual synapses in labelled sections,
in the simple, few-compartment case (todo).</p>
<p>For Strategy 2, post-synaptic parameters are specified in the <code class="xref py py-class docutils literal"><span class="pre">Connector</span></code> class, see next section.</p>
<p>In making synaptic connections <em>from</em> neurons with detailed morphologies,
we need to consider the location of the source of the action potential.
Where the axon is represented explicitly, this location could be any point in the axon (terminal section or en-passant).
Where the axon is not represented explicitly or is truncated, this location will be the soma, action initial segment,
or terminal point of the truncation.
In this case the synaptic delay should include a distance-dependent component, where the distance could be
as-the-crow-flies, or the path length along the original axon (before truncation).
In both cases, this is specified using the <cite>source</cite> argument of the <code class="xref py py-class docutils literal"><span class="pre">Projection</span></code> constructor.</p>
</div>
<div class="section" id="connectors">
<h2>Connectors<a class="headerlink" href="#connectors" title="Permalink to this headline">¶</a></h2>
<p>As noted above, for a given type of synapse, we have to consider both which post-synaptic neuron to connect to
and in which location within the morphology the synapse should be.</p>
<p>In principle, these two choices could be independent, or the choice of location could depend on which post-synaptic
neuron was chosen.</p>
<p>To support the second, more general case, we propose that the PyNN <code class="xref py py-class docutils literal"><span class="pre">Connector</span></code> classes should implement
the algorithms for both choices in a single class. The first case, of independent choices, is likely to be fairly
common however, so we also propose to extend the standard connectors from earlier versions of PyNN with a
<cite>location_selector</cite> argument, so for example we might create a projection with:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">sim</span><span class="o">.</span><span class="n">Projection</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">pyramidal_cells</span><span class="p">,</span>
               <span class="n">connector</span><span class="o">=</span><span class="n">sim</span><span class="o">.</span><span class="n">AllToAllConnector</span><span class="p">(</span><span class="n">location_selector</span><span class="o">=</span><span class="n">sample</span><span class="p">(</span><span class="n">apical_dendrites</span><span class="p">())),</span>
               <span class="n">synapse_type</span><span class="o">=</span><span class="n">sim</span><span class="o">.</span><span class="n">StaticSynapse</span><span class="p">(</span><span class="n">weight</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mf">0.5</span><span class="p">),</span>
               <span class="n">receptor_type</span><span class="o">=</span><span class="s2">&quot;AMPA&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>This will connect all inputs to all pyramidal cells, selecting one synapse location at random from the apical dendrites
(this random location would be different for each neuron in the pyramidal cell population).</p>
<p>If Strategy 1 (as described above) is being used,
the random sample is over those post-synaptic mechanisms already placed in the apical dendrites.</p>
<p>If Strategy 2 is being used, the random sample is over all possible locations in the apical dendrites,
and the post-synaptic mechanism is inserted at the same time as the connection is created.
In this scenario, it should be possible to set post-synaptic model and parameters at the same time, for example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">sim</span><span class="o">.</span><span class="n">Projection</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">pyramidal_cells</span><span class="p">,</span>
           <span class="n">connector</span><span class="o">=</span><span class="n">sim</span><span class="o">.</span><span class="n">AllToAllConnector</span><span class="p">(</span><span class="n">location_selector</span><span class="o">=</span><span class="n">sample</span><span class="p">(</span><span class="n">apical_dendrites</span><span class="p">())),</span>
           <span class="n">synapse_type</span><span class="o">=</span><span class="n">sim</span><span class="o">.</span><span class="n">StaticSynapse</span><span class="p">(</span><span class="n">weight</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mf">0.5</span><span class="p">),</span>
           <span class="n">receptor_type</span><span class="o">=</span><span class="n">sim</span><span class="o">.</span><span class="n">CondExpPostSynapticResponse</span><span class="p">(</span><span class="n">tau_syn</span><span class="o">=</span><span class="n">RandomDistribution</span><span class="p">(</span><span class="s1">&#39;normal&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">))))</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/pyNN_logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Multicompartmental modelling with PyNN: extensions to the API</a><ul>
<li><a class="reference internal" href="#cell-types">Cell types</a></li>
<li><a class="reference internal" href="#parameterization">Parameterization</a></li>
<li><a class="reference internal" href="#morphologies">Morphologies</a><ul>
<li><a class="reference internal" href="#selecting-points-and-regions">Selecting points and regions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#projections">Projections</a></li>
<li><a class="reference internal" href="#connectors">Connectors</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="mc_aims.html"
                        title="previous chapter">Multicompartmental modelling with PyNN: design goals</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="mc_examples.html"
                        title="next chapter">Multicompartmental modelling with PyNN: examples</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/mc_api.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="mc_examples.html" title="Multicompartmental modelling with PyNN: examples"
             >next</a> |</li>
        <li class="right" >
          <a href="mc_aims.html" title="Multicompartmental modelling with PyNN: design goals"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">PyNN 2.0.0.alpha.1 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2006-2017, the PyNN community.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.3.
    </div>
  </body>
</html>