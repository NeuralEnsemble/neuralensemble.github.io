
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pyNN.common.populations &#8212; PyNN 0.9.6 documentation</title>
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/nature.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../_static/pyNN_icon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">PyNN 0.9.6 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">pyNN.common.populations</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pyNN.common.populations</h1><div class="highlight"><pre>
<span></span><span class="c1"># encoding: utf-8</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Common implementation of ID, Population, PopulationView and Assembly classes.</span>

<span class="sd">These base classes should be sub-classed by the backend-specific classes.</span>

<span class="sd">:copyright: Copyright 2006-2020 by the PyNN team, see AUTHORS.</span>
<span class="sd">:license: CeCILL, see LICENSE for details.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">chain</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">basestring</span>
    <span class="n">reduce</span>
<span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
    <span class="n">basestring</span> <span class="o">=</span> <span class="nb">str</span>
    <span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">reduce</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">pyNN</span> <span class="k">import</span> <span class="n">random</span><span class="p">,</span> <span class="n">recording</span><span class="p">,</span> <span class="n">errors</span><span class="p">,</span> <span class="n">standardmodels</span><span class="p">,</span> <span class="n">core</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="n">descriptions</span>
<span class="kn">from</span> <span class="nn">pyNN.models</span> <span class="k">import</span> <span class="n">BaseCellType</span>
<span class="kn">from</span> <span class="nn">pyNN.parameters</span> <span class="k">import</span> <span class="n">ParameterSpace</span><span class="p">,</span> <span class="n">LazyArray</span><span class="p">,</span> <span class="n">simplify</span> <span class="k">as</span> <span class="n">simplify_parameter_array</span>
<span class="kn">from</span> <span class="nn">pyNN.recording</span> <span class="k">import</span> <span class="n">files</span>


<span class="n">deprecated</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">deprecated</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;PyNN&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_conductance</span><span class="p">(</span><span class="n">target_cell</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True if the target cell uses conductance-based synapses, False if</span>
<span class="sd">    it uses current-based synapses, and None if the synapse-basis cannot be</span>
<span class="sd">    determined.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">target_cell</span><span class="p">,</span> <span class="s1">&#39;local&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">target_cell</span><span class="o">.</span><span class="n">local</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">target_cell</span><span class="p">,</span> <span class="s1">&#39;celltype&#39;</span><span class="p">):</span>
        <span class="n">is_conductance</span> <span class="o">=</span> <span class="n">target_cell</span><span class="o">.</span><span class="n">celltype</span><span class="o">.</span><span class="n">conductance_based</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">is_conductance</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">is_conductance</span>


<span class="k">class</span> <span class="nc">IDMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Instead of storing ids as integers, we store them as ID objects,</span>
<span class="sd">    which allows a syntax like:</span>
<span class="sd">        p[3,4].tau_m = 20.0</span>
<span class="sd">    where p is a Population object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Simulator ID classes should inherit both from the base type of the ID</span>
    <span class="c1"># (e.g., int or long) and from IDMixin.</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;parent&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;parent is not set&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;set&quot;</span><span class="p">:</span>
            <span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;For individual cells, set values using the parameter name directly, &quot;</span> \
                     <span class="s2">&quot;e.g. population[0].tau_m = 20.0, or use &#39;set&#39; on a population view, &quot;</span> \
                     <span class="s2">&quot;e.g. population[0:1].set(tau_m=20.0)&quot;</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parameters</span><span class="p">()[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">NonExistentParameterError</span><span class="p">(</span><span class="n">name</span><span class="p">,</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">celltype</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">celltype</span><span class="o">.</span><span class="n">get_parameter_names</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">val</span>

    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;parent&quot;</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">celltype</span><span class="o">.</span><span class="n">has_parameter</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_parameters</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">value</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">parameters</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set cell parameters, given as a sequence of parameter=value arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if some of the parameters are computed from the values of other</span>
        <span class="c1"># parameters, need to get and translate all parameters</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">as_view</span><span class="p">()</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="o">**</span><span class="n">parameters</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">NotLocalError</span><span class="p">(</span><span class="s2">&quot;Cannot set parameters for a cell that does not exist on this node.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a dict of all cell parameters.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="p">:</span>
            <span class="n">parameter_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">celltype</span><span class="o">.</span><span class="n">get_parameter_names</span><span class="p">()</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">parameter_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_view</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">parameter_names</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">NotLocalError</span><span class="p">(</span><span class="s2">&quot;Cannot obtain parameters for a cell that does not exist on this node.&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">celltype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">celltype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_standard_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">celltype</span><span class="p">,</span> <span class="n">standardmodels</span><span class="o">.</span><span class="n">StandardCellType</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the cell position in 3D space.</span>

<span class="sd">        Cell positions are stored in an array in the parent Population.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">_set_cell_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_position</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the cell position in 3D space.</span>

<span class="sd">        Cell positions are stored in an array in the parent Population, if any,</span>
<span class="sd">        or within the ID object otherwise. Positions are generated the first</span>
<span class="sd">        time they are requested and then cached.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">_get_cell_position</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="n">position</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_position</span><span class="p">,</span> <span class="n">_set_position</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">local</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">is_local</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">inject</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_source</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inject current from a current source object into the cell.&quot;&quot;&quot;</span>
        <span class="n">current_source</span><span class="o">.</span><span class="n">inject_into</span><span class="p">([</span><span class="bp">self</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">get_initial_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the initial value of a state variable of the cell.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">_get_cell_initial_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_initial_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the initial value of a state variable of the cell.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">_set_cell_initial_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">as_view</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a PopulationView containing just this cell.&quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">id_to_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">index</span><span class="p">:</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">BasePopulation</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">_record_filter</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return either a single cell (ID object) from the Population, if `index`</span>
<span class="sd">        is an integer, or a subset of the cells (PopulationView object), if</span>
<span class="sd">        `index` is a slice or array.</span>

<span class="sd">        Note that __getitem__ is called when using [] access, e.g.</span>
<span class="sd">            p = Population(...)</span>
<span class="sd">            p[2] is equivalent to p.__getitem__(2).</span>
<span class="sd">            p[3:6] is equivalent to p.__getitem__(slice(3, 6))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_cells</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="nb">slice</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_view</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_view</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;indices must be integers, slices, lists, arrays or tuples, not </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the total number of cells in the population (all nodes).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">local_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of cells in the population on the local MPI node&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local_cells</span><span class="p">)</span>  <span class="c1"># would self._mask_local.sum() be faster?</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterator over cell ids on the local node.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local_cells</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">conductance_based</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Indicates whether the post-synaptic response is modelled as a change</span>
<span class="sd">        in conductance or a change in current.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">celltype</span><span class="o">.</span><span class="n">conductance_based</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">receptor_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">celltype</span><span class="o">.</span><span class="n">receptor_types</span>

    <span class="k">def</span> <span class="nf">is_local</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Indicates whether the cell with the given ID exists on the local MPI node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">id</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="bp">self</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_to_index</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask_local</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterator over cell ids on all MPI nodes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_cells</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A Population/PopulationView can be added to another Population,</span>
<span class="sd">        PopulationView or Assembly, returning an Assembly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BasePopulation</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assembly_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_cell_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_to_index</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span> <span class="n">index</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_set_cell_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_to_index</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span> <span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">position_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># &quot;generator&quot; is a misleading name, has no yield statement</span>
        <span class="k">def</span> <span class="nf">gen</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">gen</span>

    <span class="k">def</span> <span class="nf">_get_cell_initial_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">variable</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_values</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_values</span><span class="p">[</span><span class="n">variable</span><span class="p">],</span> <span class="n">LazyArray</span><span class="p">)</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_to_local_index</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_values</span><span class="p">[</span><span class="n">variable</span><span class="p">][</span><span class="n">index</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Variable &#39;</span><span class="si">{}</span><span class="s2">&#39; is not in initial values, returning 0.0&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">variable</span><span class="p">))</span>
            <span class="k">return</span> <span class="mf">0.0</span>

    <span class="k">def</span> <span class="nf">_set_cell_initial_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_values</span><span class="p">[</span><span class="n">variable</span><span class="p">],</span> <span class="n">LazyArray</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_to_local_index</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_values</span><span class="p">[</span><span class="n">variable</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">nearest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the neuron closest to the specified position.&quot;&quot;&quot;</span>
        <span class="c1"># doesn&#39;t always work correctly if a position is equidistant between</span>
        <span class="c1"># two neurons, i.e. 0.5 should be rounded up, but it isn&#39;t always.</span>
        <span class="c1"># also doesn&#39;t take account of periodic boundary conditions</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">position</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">dist_arr</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="n">pos</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">dist_arr</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">nearest</span> <span class="o">=</span> <span class="n">distances</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">nearest</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Randomly sample `n` cells from the Population, and return a</span>
<span class="sd">        PopulationView object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">rng</span><span class="p">:</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">NumpyRNG</span><span class="p">()</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">))[</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="p">]</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;The </span><span class="si">%d</span><span class="s2"> cells selected have indices </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">indices</span><span class="p">))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.sample(</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_view</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameter_names</span><span class="p">,</span> <span class="n">gather</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the values of the given parameters for every local cell in the</span>
<span class="sd">        population, or, if gather=True, for all cells in the population.</span>

<span class="sd">        Values will be expressed in the standard PyNN units (i.e. millivolts,</span>
<span class="sd">        nanoamps, milliseconds, microsiemens, nanofarads, event per second).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if all the cells have the same value for a parameter, should</span>
        <span class="c1"># we return just the number, rather than an array?</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parameter_names</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="n">parameter_names</span> <span class="o">=</span> <span class="p">(</span><span class="n">parameter_names</span><span class="p">,)</span>
            <span class="n">return_list</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">return_list</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">celltype</span><span class="p">,</span> <span class="n">standardmodels</span><span class="o">.</span><span class="n">StandardCellType</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">celltype</span><span class="o">.</span><span class="n">computed_parameters</span><span class="p">()</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">parameter_names</span><span class="p">):</span>
                <span class="n">native_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">celltype</span><span class="o">.</span><span class="n">get_native_names</span><span class="p">()</span>  <span class="c1"># need all parameters in order to calculate values</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">native_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">celltype</span><span class="o">.</span><span class="n">get_native_names</span><span class="p">(</span><span class="o">*</span><span class="n">parameter_names</span><span class="p">)</span>
            <span class="n">native_parameter_space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_parameters</span><span class="p">(</span><span class="o">*</span><span class="n">native_names</span><span class="p">)</span>
            <span class="n">parameter_space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">celltype</span><span class="o">.</span><span class="n">reverse_translate</span><span class="p">(</span><span class="n">native_parameter_space</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">parameter_space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_parameters</span><span class="p">(</span><span class="o">*</span><span class="n">parameter_names</span><span class="p">)</span>
        <span class="n">parameter_space</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">simplify</span><span class="o">=</span><span class="n">simplify</span><span class="p">)</span>  <span class="c1"># what if parameter space is homogeneous on some nodes but not on others?</span>
                                                     <span class="c1"># this also causes problems if the population size matches the number of MPI nodes</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">parameter_space</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">gather</span> <span class="o">==</span> <span class="kc">True</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simulator</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">num_processes</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># seems inefficient to do it in a loop - should do as single operation</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">parameter_names</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="n">all_values</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_simulator</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">mpi_rank</span><span class="p">:</span> <span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()}</span>
                    <span class="n">local_indices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,)[</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask_local</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="n">all_indices</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_simulator</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">mpi_rank</span><span class="p">:</span> <span class="n">local_indices</span><span class="p">}</span>
                    <span class="n">all_values</span> <span class="o">=</span> <span class="n">recording</span><span class="o">.</span><span class="n">gather_dict</span><span class="p">(</span><span class="n">all_values</span><span class="p">)</span>
                    <span class="n">all_indices</span> <span class="o">=</span> <span class="n">recording</span><span class="o">.</span><span class="n">gather_dict</span><span class="p">(</span><span class="n">all_indices</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simulator</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">mpi_rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">values</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="n">all_values</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                        <span class="n">indices</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="n">all_indices</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                        <span class="n">idx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
                        <span class="n">values</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">parameters</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">parameters</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">parameter_names</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">NonExistentParameterError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">. Valid parameters for </span><span class="si">%s</span><span class="s2"> are: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">err</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">celltype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">celltype</span><span class="o">.</span><span class="n">get_parameter_names</span><span class="p">()))</span>
        <span class="k">if</span> <span class="n">return_list</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">parameter_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">parameters</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set one or more parameters for every cell in the population.</span>

<span class="sd">        Values passed to set() may be:</span>
<span class="sd">            (1) single values</span>
<span class="sd">            (2) RandomDistribution objects</span>
<span class="sd">            (3) lists/arrays of values of the same size as the population</span>
<span class="sd">            (4) mapping functions, where a mapping function accepts a single</span>
<span class="sd">                argument (the cell index) and returns a single value.</span>

<span class="sd">        Here, a &quot;single value&quot; may be either a single number or a list/array of</span>
<span class="sd">        numbers (e.g. for spike times). Values should be expressed in the</span>
<span class="sd">        standard PyNN units (i.e. millivolts, nanoamps, milliseconds,</span>
<span class="sd">        microsiemens, nanofarads, event per second).</span>

<span class="sd">        Examples::</span>

<span class="sd">            p.set(tau_m=20.0, v_rest=-65).</span>
<span class="sd">            p.set(spike_times=[0.3, 0.7, 0.9, 1.4])</span>
<span class="sd">            p.set(cm=rand_distr, tau_m=lambda i: 10 + i/10.0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: add example using of function of (x,y,z) and Population.position_generator</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">celltype</span><span class="p">,</span> <span class="n">standardmodels</span><span class="o">.</span><span class="n">StandardCellType</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">celltype</span><span class="o">.</span><span class="n">computed_parameters</span><span class="p">()</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">)):</span>
                <span class="c1"># need to get existing parameter space of models so we can perform calculations</span>
                <span class="n">native_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">celltype</span><span class="o">.</span><span class="n">get_native_names</span><span class="p">()</span>
                <span class="n">parameter_space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">celltype</span><span class="o">.</span><span class="n">reverse_translate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_parameters</span><span class="p">(</span><span class="o">*</span><span class="n">native_names</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                    <span class="n">parameter_space</span><span class="o">.</span><span class="n">expand</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask_local</span><span class="p">)</span>
                <span class="n">parameter_space</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="n">parameters</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parameter_space</span> <span class="o">=</span> <span class="n">ParameterSpace</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">celltype</span><span class="o">.</span><span class="n">get_schema</span><span class="p">(),</span>
                                                 <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,),</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">celltype</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">celltype</span><span class="p">,</span> <span class="n">standardmodels</span><span class="o">.</span><span class="n">StandardCellType</span><span class="p">):</span>
                <span class="n">parameter_space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">celltype</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">parameter_space</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">parameter_space</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,),</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> != </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">parameter_space</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_parameters</span><span class="p">(</span><span class="n">parameter_space</span><span class="p">)</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;set(parametername=value_array)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">tset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parametername</span><span class="p">,</span> <span class="n">value_array</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &#39;Topographic&#39; set. Set the value of parametername to the values in</span>
<span class="sd">        value_array, which must have the same dimensions as the Population.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">parametername</span><span class="p">:</span> <span class="n">value_array</span><span class="p">})</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;set(parametername=rand_distr)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">rset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parametername</span><span class="p">,</span> <span class="n">rand_distr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &#39;Random&#39; set. Set the value of parametername to a value taken from</span>
<span class="sd">        rand_distr, which should be a RandomDistribution object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Note that we generate enough random numbers for all cells on all nodes</span>
        <span class="c1"># but use only those relevant to this node. This ensures that the</span>
        <span class="c1"># sequence of random numbers does not depend on the number of nodes,</span>
        <span class="c1"># provided that the same rng with the same seed is used on each node.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">parametername</span><span class="p">:</span> <span class="n">rand_distr</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">initial_values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set initial values of state variables, e.g. the membrane potential.</span>

<span class="sd">        Values passed to initialize() may be:</span>
<span class="sd">            (1) single numeric values (all neurons set to the same value)</span>
<span class="sd">            (2) RandomDistribution objects</span>
<span class="sd">            (3) lists/arrays of numbers of the same size as the population</span>
<span class="sd">            (4) mapping functions, where a mapping function accepts a single</span>
<span class="sd">                argument (the cell index) and returns a single number.</span>

<span class="sd">        Values should be expressed in the standard PyNN units (i.e. millivolts,</span>
<span class="sd">        nanoamps, milliseconds, microsiemens, nanofarads, event per second).</span>

<span class="sd">        Examples::</span>

<span class="sd">            p.initialize(v=-70.0)</span>
<span class="sd">            p.initialize(v=rand_distr, gsyn_exc=0.0)</span>
<span class="sd">            p.initialize(v=lambda i: -65 + i/10.0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">variable</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">initial_values</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;In Population &#39;</span><span class="si">%s</span><span class="s2">&#39;, initialising </span><span class="si">%s</span><span class="s2"> to </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
            <span class="n">initial_value</span> <span class="o">=</span> <span class="n">LazyArray</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_initial_value_array</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">initial_value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initial_values</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">initial_value</span>

    <span class="k">def</span> <span class="nf">find_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns units of the specified variable or parameter, as a string.</span>
<span class="sd">        Works for all the recordable variables and neuron parameters of all standard models.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">celltype</span><span class="o">.</span><span class="n">units</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">annotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">annotations</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">annotations</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">can_record</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determine whether `variable` can be recorded from this population.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">celltype</span><span class="o">.</span><span class="n">can_record</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">injectable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">celltype</span><span class="o">.</span><span class="n">injectable</span>

    <span class="k">def</span> <span class="nf">record</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">to_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sampling_interval</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Record the specified variable or variables for all cells in the</span>
<span class="sd">        Population or view.</span>

<span class="sd">        `variables` may be either a single variable name or a list of variable</span>
<span class="sd">        names. For a given celltype class, `celltype.recordable` contains a list of</span>
<span class="sd">        variables that can be recorded for that celltype.</span>

<span class="sd">        If specified, `to_file` should be either a filename or a Neo IO instance and `write_data()`</span>
<span class="sd">        will be automatically called when `end()` is called.</span>

<span class="sd">        `sampling_interval` should be a value in milliseconds, and an integer</span>
<span class="sd">        multiple of the simulation timestep.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">variables</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># reset the list of things to record</span>
                               <span class="c1"># note that if record(None) is called on a view of a population</span>
                               <span class="c1"># recording will be reset for the entire population, not just the view</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">recorder</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.record(&#39;</span><span class="si">%s</span><span class="s2">&#39;)&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">variables</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_record_filter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">recorder</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_cells</span><span class="p">,</span> <span class="n">sampling_interval</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">recorder</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_record_filter</span><span class="p">,</span> <span class="n">sampling_interval</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">to_file</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">recorder</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="n">to_file</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_simulator</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">write_on_end</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">recorder</span><span class="o">.</span><span class="n">file</span><span class="p">))</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;record(&#39;v&#39;)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">record_v</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_file</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Record the membrane potential for all cells in the Population.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="n">to_file</span><span class="p">)</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;record([&#39;gsyn_exc&#39;, &#39;gsyn_inh&#39;])&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">record_gsyn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_file</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Record synaptic conductances for all cells in the Population.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="p">([</span><span class="s1">&#39;gsyn_exc&#39;</span><span class="p">,</span> <span class="s1">&#39;gsyn_inh&#39;</span><span class="p">],</span> <span class="n">to_file</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">io</span><span class="p">,</span> <span class="n">variables</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">gather</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">clear</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">annotations</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write recorded data to file, using one of the file formats supported by</span>
<span class="sd">        Neo.</span>

<span class="sd">        `io`:</span>
<span class="sd">            a Neo IO instance</span>
<span class="sd">        `variables`:</span>
<span class="sd">            either a single variable name or a list of variable names.</span>
<span class="sd">            Variables must have been previously recorded, otherwise an</span>
<span class="sd">            Exception will be raised.</span>

<span class="sd">        For parallel simulators, if `gather` is True, all data will be gathered</span>
<span class="sd">        to the master node and a single output file created there. Otherwise, a</span>
<span class="sd">        file will be written on each node, containing only data from the cells</span>
<span class="sd">        simulated on that node.</span>

<span class="sd">        If `clear` is True, recorded data will be deleted from the `Population`.</span>

<span class="sd">        `annotations` should be a dict containing simple data types such as</span>
<span class="sd">        numbers and strings. The contents will be written into the output data</span>
<span class="sd">        file as metadata.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Population </span><span class="si">%s</span><span class="s2"> is writing </span><span class="si">%s</span><span class="s2"> to </span><span class="si">%s</span><span class="s2"> [gather=</span><span class="si">%s</span><span class="s2">, clear=</span><span class="si">%s</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">io</span><span class="p">,</span> <span class="n">gather</span><span class="p">,</span> <span class="n">clear</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recorder</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">io</span><span class="p">,</span> <span class="n">gather</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_record_filter</span><span class="p">,</span> <span class="n">clear</span><span class="o">=</span><span class="n">clear</span><span class="p">,</span>
                            <span class="n">annotations</span><span class="o">=</span><span class="n">annotations</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">gather</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">clear</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a Neo `Block` containing the data (spikes, state variables)</span>
<span class="sd">        recorded from the Population.</span>

<span class="sd">        `variables` - either a single variable name or a list of variable names</span>
<span class="sd">                      Variables must have been previously recorded, otherwise an</span>
<span class="sd">                      Exception will be raised.</span>

<span class="sd">        For parallel simulators, if `gather` is True, all data will be gathered</span>
<span class="sd">        to all nodes and the Neo `Block` will contain data from all nodes.</span>
<span class="sd">        Otherwise, the Neo `Block` will contain only data from the cells</span>
<span class="sd">        simulated on the local node.</span>

<span class="sd">        If `clear` is True, recorded data will be deleted from the `Population`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">recorder</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">gather</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_record_filter</span><span class="p">,</span> <span class="n">clear</span><span class="p">)</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;write_data(file, &#39;spikes&#39;)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">printSpikes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">gather</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">compatible_output</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write_data</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s1">&#39;spikes&#39;</span><span class="p">,</span> <span class="n">gather</span><span class="p">)</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;get_data(&#39;spikes&#39;)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">getSpikes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gather</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">compatible_output</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="s1">&#39;spikes&#39;</span><span class="p">,</span> <span class="n">gather</span><span class="p">)</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;write_data(file, &#39;v&#39;)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">print_v</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">gather</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">compatible_output</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write_data</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="n">gather</span><span class="p">)</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;get_data(&#39;v&#39;)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_v</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gather</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">compatible_output</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="n">gather</span><span class="p">)</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;write_data(file, [&#39;gsyn_exc&#39;, &#39;gsyn_inh&#39;])&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">print_gsyn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">gather</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">compatible_output</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write_data</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;gsyn_exc&#39;</span><span class="p">,</span> <span class="s1">&#39;gsyn_inh&#39;</span><span class="p">],</span> <span class="n">gather</span><span class="p">)</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;get_data([&#39;gsyn_exc&#39;, &#39;gsyn_inh&#39;])&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_gsyn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gather</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">compatible_output</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">([</span><span class="s1">&#39;gsyn_exc&#39;</span><span class="p">,</span> <span class="s1">&#39;gsyn_inh&#39;</span><span class="p">],</span> <span class="n">gather</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_spike_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gather</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dict containing the number of spikes for each neuron.</span>

<span class="sd">        The dict keys are neuron IDs, not indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># arguably, we should use indices</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">recorder</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;spikes&#39;</span><span class="p">,</span> <span class="n">gather</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_record_filter</span><span class="p">)</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;mean_spike_count()&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">meanSpikeCount</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gather</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_spike_count</span><span class="p">(</span><span class="n">gather</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mean_spike_count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gather</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the mean number of spikes per neuron.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spike_counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spike_counts</span><span class="p">(</span><span class="n">gather</span><span class="p">)</span>
        <span class="n">total_spikes</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">spike_counts</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simulator</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">mpi_rank</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">gather</span><span class="p">:</span>  <span class="c1"># should maybe use allgather, and get the numbers on all nodes</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spike_counts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">total_spikes</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">spike_counts</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">def</span> <span class="nf">inject</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_source</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Connect a current source to all cells in the Population.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">celltype</span><span class="o">.</span><span class="n">injectable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t inject current into a spike source.&quot;</span><span class="p">)</span>
        <span class="n">current_source</span><span class="o">.</span><span class="n">inject_into</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1"># name should be consistent with saving/writing data, i.e. save_data() and save_positions() or write_data() and write_positions()</span>
    <span class="k">def</span> <span class="nf">save_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save positions to file. The output format is ``index x y z``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="n">file</span> <span class="o">=</span> <span class="n">recording</span><span class="o">.</span><span class="n">files</span><span class="o">.</span><span class="n">StandardTextFile</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_cells</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">cells</span><span class="p">),</span> <span class="mi">4</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">id_to_index</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">])</span>
        <span class="n">result</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">T</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simulator</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">mpi_rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;population&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">})</span>
            <span class="n">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">Population</span><span class="p">(</span><span class="n">BasePopulation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A group of neurons all of the same type. &quot;Population&quot; is used as a generic</span>
<span class="sd">    term intended to include layers, columns, nuclei, etc., of cells.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        `size`:</span>
<span class="sd">            number of cells in the Population. For backwards-compatibility,</span>
<span class="sd">            `size` may also be a tuple giving the dimensions of a grid,</span>
<span class="sd">            e.g. ``size=(10,10)`` is equivalent to ``size=100`` with ``structure=Grid2D()``.</span>

<span class="sd">        `cellclass`:</span>
<span class="sd">            a cell type (a class inheriting from :class:`pyNN.models.BaseCellType`).</span>

<span class="sd">        `cellparams`:</span>
<span class="sd">            a dict, or other mapping, containing parameters, which is passed to</span>
<span class="sd">            the neuron model constructor.</span>

<span class="sd">        `structure`:</span>
<span class="sd">            a :class:`pyNN.space.Structure` instance, used to specify the</span>
<span class="sd">            positions of neurons in space.</span>

<span class="sd">        `initial_values`:</span>
<span class="sd">            a dict, or other mapping, containing initial values for the neuron</span>
<span class="sd">            state variables.</span>

<span class="sd">        `label`:</span>
<span class="sd">            a name for the population. One will be auto-generated if this is not</span>
<span class="sd">            supplied.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_nPop</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">cellclass</span><span class="p">,</span> <span class="n">cellparams</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">initial_values</span><span class="o">=</span><span class="p">{},</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a population of neurons all of the same type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_simulator&quot;</span><span class="p">):</span>
            <span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;`common.Population` should not be instantiated directly. &quot;</span> \
                     <span class="s2">&quot;You should import Population from a PyNN backend module, &quot;</span> \
                     <span class="s2">&quot;e.g. pyNN.nest or pyNN.neuron&quot;</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>  <span class="c1"># also allow a single integer, for a 1D population</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">),</span> <span class="s2">&quot;`size` must be an integer or a tuple of ints. You have supplied a </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
            <span class="c1"># check the things inside are ints</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">size</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s2">&quot;`size` must be an integer or a tuple of ints. Element &#39;</span><span class="si">%s</span><span class="s2">&#39; is not an int&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

            <span class="k">assert</span> <span class="n">structure</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;If you specify `size` as a tuple you may not specify structure.&quot;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">structure</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">Line</span><span class="p">()</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">size</span>
                <span class="n">structure</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">Grid2D</span><span class="p">(</span><span class="n">nx</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">ny</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="n">size</span>
                <span class="n">structure</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">Grid3D</span><span class="p">(</span><span class="n">nx</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">ny</span><span class="p">),</span> <span class="n">nx</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">nz</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;A maximum of 3 dimensions is allowed. What do you think this is, string theory?&quot;</span><span class="p">)</span>
            <span class="n">size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>  <span class="c1"># NEST doesn&#39;t like numpy.int, so to be safe we cast to Python int</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span> <span class="ow">or</span> <span class="s1">&#39;population</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">Population</span><span class="o">.</span><span class="n">_nPop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span> <span class="o">=</span> <span class="n">structure</span> <span class="ow">or</span> <span class="n">space</span><span class="o">.</span><span class="n">Line</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_positions</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_sorted</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cellclass</span><span class="p">,</span> <span class="n">BaseCellType</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">celltype</span> <span class="o">=</span> <span class="n">cellclass</span>
            <span class="k">assert</span> <span class="n">cellparams</span> <span class="ow">is</span> <span class="kc">None</span>   <span class="c1"># cellparams being retained for backwards compatibility, but use is deprecated</span>
        <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">cellclass</span><span class="p">,</span> <span class="n">BaseCellType</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">celltype</span> <span class="o">=</span> <span class="n">cellclass</span><span class="p">(</span><span class="o">**</span><span class="n">cellparams</span><span class="p">)</span>
            <span class="c1"># emit deprecation warning</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cellclass must be an instance or subclass of BaseCellType, not a </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">cellclass</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recorder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recorder_class</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># Build the arrays of cell ids</span>
        <span class="c1"># Cells on the local node are represented as ID objects, other cells by integers</span>
        <span class="c1"># All are stored in a single numpy array for easy lookup by address</span>
        <span class="c1"># The local cells are also stored in a list, for easy iteration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_cells</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_cells</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_values</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">all_initial_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">celltype</span><span class="o">.</span><span class="n">default_initial_values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">all_initial_values</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">initial_values</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="o">**</span><span class="n">all_initial_values</span><span class="p">)</span>
        <span class="n">Population</span><span class="o">.</span><span class="n">_nPop</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Population(</span><span class="si">%d</span><span class="s2">, </span><span class="si">%r</span><span class="s2">, structure=</span><span class="si">%r</span><span class="s2">, label=</span><span class="si">%r</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">celltype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">local_cells</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        An array containing cell ids for the local node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_cells</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask_local</span><span class="p">]</span>

<div class="viewcode-block" id="Population.id_to_index"><a class="viewcode-back" href="../../../reference/populations.html#pyNN.neuron.Population.id_to_index">[docs]</a>    <span class="k">def</span> <span class="nf">id_to_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given the ID(s) of cell(s) in the Population, return its (their) index</span>
<span class="sd">        (order in the Population).</span>

<span class="sd">            &gt;&gt;&gt; assert p.id_to_index(p[5]) == 5</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="nb">id</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_id</span> <span class="o">&lt;=</span> <span class="nb">id</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_id</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;id should be in the range [</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">], actually </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_id</span><span class="p">,</span> <span class="nb">id</span><span class="p">))</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nb">id</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_id</span><span class="p">)</span>  <span class="c1"># this assumes ids are consecutive</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="n">PopulationView</span><span class="p">):</span>
                <span class="nb">id</span> <span class="o">=</span> <span class="nb">id</span><span class="o">.</span><span class="n">all_cells</span>
            <span class="nb">id</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first_id</span> <span class="o">&gt;</span> <span class="nb">id</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_id</span> <span class="o">&lt;</span> <span class="nb">id</span><span class="o">.</span><span class="n">max</span><span class="p">()):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ids should be in the range [</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">], actually [</span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_id</span><span class="p">,</span> <span class="nb">id</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="nb">id</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>
            <span class="k">return</span> <span class="p">(</span><span class="nb">id</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_id</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>  <span class="c1"># this assumes ids are consecutive</span></div>

<div class="viewcode-block" id="Population.id_to_local_index"><a class="viewcode-back" href="../../../reference/populations.html#pyNN.neuron.Population.id_to_local_index">[docs]</a>    <span class="k">def</span> <span class="nf">id_to_local_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given the ID(s) of cell(s) in the Population, return its (their) index</span>
<span class="sd">        (order in the Population), counting only cells on the local MPI node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simulator</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">num_processes</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_cells</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>          <span class="c1"># probably very slow</span>
            <span class="c1">#return numpy.nonzero(self.local_cells == id)[0][0] # possibly faster?</span>
            <span class="c1"># another idea - get global index, use idx-sum(mask_local[:idx])?</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_to_index</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_get_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The spatial structure of the Population.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span>

    <span class="k">def</span> <span class="nf">_set_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">space</span><span class="o">.</span><span class="n">BaseStructure</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">structure</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_positions</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># setting a new structure invalidates previously calculated positions</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span> <span class="o">=</span> <span class="n">structure</span>
    <span class="n">structure</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="n">_get_structure</span><span class="p">,</span> <span class="n">fset</span><span class="o">=</span><span class="n">_set_structure</span><span class="p">)</span>
    <span class="c1"># arguably structure should be read-only, i.e. it is not possible to change it after Population creation</span>

    <span class="k">def</span> <span class="nf">_get_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Try to return self._positions. If it does not exist, create it and then</span>
<span class="sd">        return it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_positions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_positions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">generate_positions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_positions</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_positions</span>

    <span class="k">def</span> <span class="nf">_set_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos_array</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pos_array</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">pos_array</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> != </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">pos_array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_positions</span> <span class="o">=</span> <span class="n">pos_array</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># take a copy in case pos_array is changed later</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># explicitly setting positions destroys any previous structure</span>

    <span class="n">positions</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_positions</span><span class="p">,</span> <span class="n">_set_positions</span><span class="p">,</span>
                         <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;A 3xN array (where N is the number of neurons in the Population)</span>
<span class="s2">                         giving the x,y,z coordinates of all the neurons (soma, in the</span>
<span class="s2">                         case of non-point models).&quot;&quot;&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Population.describe"><a class="viewcode-back" href="../../../reference/populations.html#pyNN.neuron.Population.describe">[docs]</a>    <span class="k">def</span> <span class="nf">describe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">template</span><span class="o">=</span><span class="s1">&#39;population_default.txt&#39;</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a human-readable description of the population.</span>

<span class="sd">        The output may be customized by specifying a different template</span>
<span class="sd">        together with an associated template engine (see :mod:`pyNN.descriptions`).</span>

<span class="sd">        If template is None, then a dictionary containing the template context</span>
<span class="sd">        will be returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">context</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span>
            <span class="s2">&quot;celltype&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">celltype</span><span class="o">.</span><span class="n">describe</span><span class="p">(</span><span class="n">template</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span>
            <span class="s2">&quot;structure&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;size&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>
            <span class="s2">&quot;size_local&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local_cells</span><span class="p">),</span>
            <span class="s2">&quot;first_id&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_id</span><span class="p">,</span>
            <span class="s2">&quot;last_id&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_id</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">context</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">annotations</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local_cells</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">first_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">context</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
                <span class="s2">&quot;local_first_id&quot;</span><span class="p">:</span> <span class="n">first_id</span><span class="p">,</span>
                <span class="s2">&quot;cell_parameters&quot;</span><span class="p">:</span> <span class="p">{}</span>  <span class="c1"># first_id.get_parameters(),</span>
            <span class="p">})</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">:</span>
            <span class="n">context</span><span class="p">[</span><span class="s2">&quot;structure&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">describe</span><span class="p">(</span><span class="n">template</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">descriptions</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">PopulationView</span><span class="p">(</span><span class="n">BasePopulation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A view of a subset of neurons within a Population.</span>

<span class="sd">    In most ways, Populations and PopulationViews have the same behaviour, i.e.</span>
<span class="sd">    they can be recorded, connected with Projections, etc. It should be noted</span>
<span class="sd">    that any changes to neurons in a PopulationView will be reflected in the</span>
<span class="sd">    parent Population and vice versa.</span>

<span class="sd">    It is possible to have views of views.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        selector:</span>
<span class="sd">            a slice or numpy mask array. The mask array should either be a</span>
<span class="sd">            boolean array of the same size as the parent, or an integer array</span>
<span class="sd">            containing cell indices, i.e. if p.size == 5::</span>

<span class="sd">                PopulationView(p, array([False, False, True, False, True]))</span>
<span class="sd">                PopulationView(p, array([2,4]))</span>
<span class="sd">                PopulationView(p, slice(2,5,2))</span>

<span class="sd">            will all create the same view.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">selector</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a view of a subset of neurons within a parent Population or</span>
<span class="sd">        PopulationView.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_simulator&quot;</span><span class="p">):</span>
            <span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;`common.PopulationView` should not be instantiated directly. &quot;</span> \
                     <span class="s2">&quot;You should import PopulationView from a PyNN backend module, &quot;</span> \
                     <span class="s2">&quot;e.g. pyNN.nest or pyNN.neuron&quot;</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">selector</span>  <span class="c1"># later we can have fancier selectors, for now we just have numpy masks</span>
        <span class="c1"># maybe just redefine __getattr__ instead of the following...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">celltype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">celltype</span>
        <span class="c1"># If the mask is a slice, IDs will be consecutives without duplication.</span>
        <span class="c1"># If not, then we need to remove duplicated IDs</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">is</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Boolean masks should have the size of Parent Population&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">))[</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">):</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;PopulationView can contain only once each ID, duplicated IDs are removed&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_cells</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">all_cells</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span>  <span class="c1"># do we need to ensure this is ordered?</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_cells</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_sorted</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_cells</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_cells</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span> <span class="ow">or</span> <span class="s2">&quot;view of &#39;</span><span class="si">%s</span><span class="s2">&#39; with size </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mask_local</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">_mask_local</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local_cells</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_cells</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask_local</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_id</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_cells</span><span class="p">)</span>  <span class="c1"># only works if we assume all_cells is sorted, otherwise could use min()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_id</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_cells</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recorder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">recorder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_record_filter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_cells</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;PopulationView(parent=</span><span class="si">%r</span><span class="s2">, selector=</span><span class="si">%r</span><span class="s2">, label=</span><span class="si">%r</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">initial_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># this is going to be complex - if we keep initial_values as a dict,</span>
        <span class="c1"># need to return a dict-like object that takes account of self.mask</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The spatial structure of the parent Population.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">structure</span>
    <span class="c1"># should we allow setting structure for a PopulationView? Maybe if the</span>
    <span class="c1"># parent has some kind of CompositeStructure?</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">positions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># make positions N,3 instead of 3,N to avoid all this transposing?</span>

<div class="viewcode-block" id="PopulationView.id_to_index"><a class="viewcode-back" href="../../../reference/populations.html#pyNN.neuron.PopulationView.id_to_index">[docs]</a>    <span class="k">def</span> <span class="nf">id_to_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given the ID(s) of cell(s) in the PopulationView, return its/their</span>
<span class="sd">        index/indices (order in the PopulationView).</span>

<span class="sd">            &gt;&gt;&gt; assert pv.id_to_index(pv[3]) == 3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="nb">id</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_sorted</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_cells</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;ID </span><span class="si">%s</span><span class="s2"> not present in the View&quot;</span> <span class="o">%</span> <span class="nb">id</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_cells</span><span class="p">,</span> <span class="nb">id</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_cells</span> <span class="o">==</span> <span class="nb">id</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;ID </span><span class="si">%s</span><span class="s2"> not present in the View&quot;</span> <span class="o">%</span> <span class="nb">id</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_sorted</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_cells</span><span class="p">,</span> <span class="nb">id</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">id</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_cells</span> <span class="o">==</span> <span class="n">item</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;ID </span><span class="si">%s</span><span class="s2"> not present in the View&quot;</span> <span class="o">%</span> <span class="n">item</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ID </span><span class="si">%s</span><span class="s2"> is duplicated in the View&quot;</span> <span class="o">%</span> <span class="n">item</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">result</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">grandparent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the parent Population at the root of the tree (since the</span>
<span class="sd">        immediate parent may itself be a PopulationView).</span>

<span class="sd">        The name &quot;grandparent&quot; is of course a little misleading, as it could</span>
<span class="sd">        be just the parent, or the great, great, great, ..., grandparent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="s2">&quot;parent&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">grandparent</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>

<div class="viewcode-block" id="PopulationView.index_in_grandparent"><a class="viewcode-back" href="../../../reference/populations.html#pyNN.neuron.PopulationView.index_in_grandparent">[docs]</a>    <span class="k">def</span> <span class="nf">index_in_grandparent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given an array of indices, return the indices in the parent population</span>
<span class="sd">        at the root of the tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indices_in_parent</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">size</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">][</span><span class="n">indices</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="s2">&quot;parent&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">index_in_grandparent</span><span class="p">(</span><span class="n">indices_in_parent</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">indices_in_parent</span></div>

<div class="viewcode-block" id="PopulationView.index_from_parent_index"><a class="viewcode-back" href="../../../reference/populations.html#pyNN.neuron.PopulationView.index_from_parent_index">[docs]</a>    <span class="k">def</span> <span class="nf">index_from_parent_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given an index(indices) in the parent population, return</span>
<span class="sd">        the index(indices) within this view.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># todo: add check that all indices correspond to cells that are in this view</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">start</span> <span class="ow">or</span> <span class="mi">0</span>
            <span class="n">step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">step</span> <span class="ow">or</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">indices</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="n">step</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">==</span> <span class="n">indices</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="c1"># Lots of ways to do this. Some profiling is in order.</span>
                <span class="c1"># - https://stackoverflow.com/questions/16992713/translate-every-element-in-numpy-array-according-to-key</span>
                <span class="c1"># - https://stackoverflow.com/questions/3403973/fast-replacement-of-values-in-a-numpy-array</span>
                <span class="c1"># - https://stackoverflow.com/questions/13572448/replace-values-of-a-numpy-index-array-with-values-of-a-list</span>
                <span class="n">parent_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span>  <span class="c1"># assert mask is sorted</span>
                <span class="n">view_indices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">parent_indices</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">view_indices</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;indices must be an integer or an array of integers&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine whether two views are the same.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__ne__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine whether two views are different.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We can&#39;t use the self.mask, as different masks can select the same cells</span>
        <span class="c1"># (e.g. slices vs arrays), therefore we have to use self.all_cells</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">PopulationView</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">parent</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_cells</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">all_cells</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Population</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">!=</span> <span class="n">other</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_cells</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">all_cells</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

<div class="viewcode-block" id="PopulationView.describe"><a class="viewcode-back" href="../../../reference/populations.html#pyNN.neuron.PopulationView.describe">[docs]</a>    <span class="k">def</span> <span class="nf">describe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">template</span><span class="o">=</span><span class="s1">&#39;populationview_default.txt&#39;</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a human-readable description of the population view.</span>

<span class="sd">        The output may be customized by specifying a different template</span>
<span class="sd">        togther with an associated template engine (see ``pyNN.descriptions``).</span>

<span class="sd">        If template is None, then a dictionary containing the template context</span>
<span class="sd">        will be returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">context</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span>
                   <span class="s2">&quot;parent&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">label</span><span class="p">,</span>
                   <span class="s2">&quot;mask&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span>
                   <span class="s2">&quot;size&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">}</span>
        <span class="n">context</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">annotations</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">descriptions</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">Assembly</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A group of neurons, may be heterogeneous, in contrast to a Population where</span>
<span class="sd">    all the neurons are of the same type.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        populations:</span>
<span class="sd">            Populations or PopulationViews</span>
<span class="sd">        kwargs:</span>
<span class="sd">            May contain a keyword argument &#39;label&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">populations</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an Assembly of Populations and/or PopulationViews.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_simulator&quot;</span><span class="p">):</span>
            <span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;`common.Assembly` should not be instantiated directly. &quot;</span> \
                     <span class="s2">&quot;You should import Assembly from a PyNN backend module, &quot;</span> \
                     <span class="s2">&quot;e.g. pyNN.nest or pyNN.neuron&quot;</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">populations</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">populations</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_insert</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;assembly</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">Assembly</span><span class="o">.</span><span class="n">_count</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">basestring</span><span class="p">),</span> <span class="s2">&quot;label must be a string or unicode&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">Assembly</span><span class="o">.</span><span class="n">_count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Assembly(*</span><span class="si">%r</span><span class="s2">, label=</span><span class="si">%r</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">BasePopulation</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;argument is a </span><span class="si">%s</span><span class="s2">, not a Population.&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">element</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">PopulationView</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">element</span><span class="o">.</span><span class="n">parent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">:</span>
                <span class="n">double</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">p</span><span class="o">.</span><span class="n">all_cells</span><span class="p">,</span> <span class="n">element</span><span class="o">.</span><span class="n">all_cells</span><span class="p">))</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">all_cells</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">all_cells</span><span class="p">):</span>
                        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Adding a PopulationView to an Assembly containing elements already present is not posible&#39;</span><span class="p">)</span>
                        <span class="n">double</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Should we automatically remove duplicated IDs ?</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">double</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Adding a PopulationView to an Assembly when parent Population is there is not possible&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">BasePopulation</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Adding a Population twice in an Assembly is not possible&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">local_cells</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">local_cells</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">result</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">local_cells</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">all_cells</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">all_cells</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">result</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">all_cells</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="Assembly.all"><a class="viewcode-back" href="../../../reference/populations.html#pyNN.neuron.Assembly.all">[docs]</a>    <span class="k">def</span> <span class="nf">all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterator over cell ids on all nodes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_cells</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_sorted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_cells</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_cells</span><span class="p">)))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_homogeneous_synapses</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">cb</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">celltype</span><span class="o">.</span><span class="n">conductance_based</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">conductance_based</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        `True` if the post-synaptic response is modelled as a change</span>
<span class="sd">        in conductance, `False` if a change in current.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">celltype</span><span class="o">.</span><span class="n">conductance_based</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">receptor_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of receptor types that are common to all populations</span>
<span class="sd">        within the assembly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">celltype</span><span class="o">.</span><span class="n">receptor_types</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">rts</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">rts</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">rts</span> <span class="o">=</span> <span class="n">rts</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">celltype</span><span class="o">.</span><span class="n">receptor_types</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">rts</span><span class="p">)</span>

<div class="viewcode-block" id="Assembly.find_units"><a class="viewcode-back" href="../../../reference/populations.html#pyNN.neuron.Assembly.find_units">[docs]</a>    <span class="k">def</span> <span class="nf">find_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns units of the specified variable or parameter, as a string.</span>
<span class="sd">        Works for all the recordable variables and neuron parameters of all standard models.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">units</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">find_units</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">units</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Inconsistent units&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">units</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_mask_local</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_mask_local</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">result</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">_mask_local</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">first_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_cells</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">last_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_cells</span><span class="p">)</span>

<div class="viewcode-block" id="Assembly.id_to_index"><a class="viewcode-back" href="../../../reference/populations.html#pyNN.neuron.Assembly.id_to_index">[docs]</a>    <span class="k">def</span> <span class="nf">id_to_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given the ID(s) of cell(s) in the Assembly, return its (their) index</span>
<span class="sd">        (order in the Assembly)::</span>

<span class="sd">            &gt;&gt;&gt; assert p.id_to_index(p[5]) == 5</span>
<span class="sd">            &gt;&gt;&gt; assert p.id_to_index(p.index([1, 2, 3])) == [1, 2, 3]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_cells</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_cells</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="nb">id</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_sorted</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">all_cells</span><span class="p">,</span> <span class="nb">id</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">all_cells</span> <span class="o">==</span> <span class="nb">id</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;ID </span><span class="si">%s</span><span class="s2"> not present in the View&quot;</span> <span class="o">%</span> <span class="nb">id</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_sorted</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">all_cells</span><span class="p">,</span> <span class="nb">id</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">id</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">all_cells</span> <span class="o">==</span> <span class="n">item</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;ID </span><span class="si">%s</span><span class="s2"> not present in the Assembly&quot;</span> <span class="o">%</span> <span class="n">item</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ID </span><span class="si">%s</span><span class="s2"> is duplicated in the Assembly&quot;</span> <span class="o">%</span> <span class="n">item</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">result</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">positions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">result</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">positions</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">)</span>

<div class="viewcode-block" id="Assembly.__iter__"><a class="viewcode-back" href="../../../reference/populations.html#pyNN.neuron.Assembly.__iter__">[docs]</a>    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterator over cells in all populations within the Assembly, for cells</span>
<span class="sd">        on the local MPI node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">iterators</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">iterators</span><span class="p">)</span></div>

<div class="viewcode-block" id="Assembly.__len__"><a class="viewcode-back" href="../../../reference/populations.html#pyNN.neuron.Assembly.__len__">[docs]</a>    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the total number of cells in the population (all nodes).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span></div>

<div class="viewcode-block" id="Assembly.__getitem__"><a class="viewcode-back" href="../../../reference/populations.html#pyNN.neuron.Assembly.__getitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Where `index` is an integer, return an ID.</span>
<span class="sd">        Where `index` is a slice, tuple, list or numpy array, return a new Assembly</span>
<span class="sd">        consisting of appropriate populations and (possibly newly created)</span>
<span class="sd">        population views.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">boundaries</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="n">p</span><span class="o">.</span><span class="n">size</span>
            <span class="n">boundaries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
        <span class="n">boundaries</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">boundaries</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>  <span class="c1"># return an ID</span>
            <span class="n">pindex</span> <span class="o">=</span> <span class="n">boundaries</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">[</span><span class="n">pindex</span><span class="p">][</span><span class="n">index</span> <span class="o">-</span> <span class="n">boundaries</span><span class="p">[</span><span class="n">pindex</span><span class="p">]]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="nb">slice</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">index</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)[</span><span class="n">index</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="n">pindices</span> <span class="o">=</span> <span class="n">boundaries</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
            <span class="n">views</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">indices</span><span class="p">[</span><span class="n">pindices</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">boundaries</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">pindices</span><span class="p">)]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">*</span><span class="n">views</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;indices must be integers, slices, lists, arrays, not </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span></div>

<div class="viewcode-block" id="Assembly.__add__"><a class="viewcode-back" href="../../../reference/populations.html#pyNN.neuron.Assembly.__add__">[docs]</a>    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        An Assembly may be added to a Population, PopulationView or Assembly</span>
<span class="sd">        with the &#39;+&#39; operator, returning a new Assembly, e.g.::</span>

<span class="sd">            a2 = a1 + p</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BasePopulation</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">populations</span> <span class="o">+</span> <span class="p">[</span><span class="n">other</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Assembly</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">populations</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">populations</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;can only add a Population or another Assembly to an Assembly&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Assembly.__iadd__"><a class="viewcode-back" href="../../../reference/populations.html#pyNN.neuron.Assembly.__iadd__">[docs]</a>    <span class="k">def</span> <span class="nf">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A Population, PopulationView or Assembly may be added to an existing</span>
<span class="sd">        Assembly using the &#39;+=&#39; operator, e.g.::</span>

<span class="sd">            a += p</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BasePopulation</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_insert</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Assembly</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">populations</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_insert</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;can only add a Population or another Assembly to an Assembly&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Assembly.sample"><a class="viewcode-back" href="../../../reference/populations.html#pyNN.neuron.Assembly.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Randomly sample `n` cells from the Assembly, and return a Assembly</span>
<span class="sd">        object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">rng</span><span class="p">:</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">NumpyRNG</span><span class="p">()</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">))[</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="p">]</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;The </span><span class="si">%d</span><span class="s2"> cells recorded have indices </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">indices</span><span class="p">))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.sample(</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span></div>

<div class="viewcode-block" id="Assembly.initialize"><a class="viewcode-back" href="../../../reference/populations.html#pyNN.neuron.Assembly.initialize">[docs]</a>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">initial_values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the initial values of the state variables of the neurons in</span>
<span class="sd">        this assembly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="o">**</span><span class="n">initial_values</span><span class="p">)</span></div>

<div class="viewcode-block" id="Assembly.get"><a class="viewcode-back" href="../../../reference/populations.html#pyNN.neuron.Assembly.get">[docs]</a>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameter_names</span><span class="p">,</span> <span class="n">gather</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the values of the given parameters for every local cell in the</span>
<span class="sd">        Assembly, or, if gather=True, for all cells in the Assembly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parameter_names</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="n">parameter_names</span> <span class="o">=</span> <span class="p">(</span><span class="n">parameter_names</span><span class="p">,)</span>
            <span class="n">return_list</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">return_list</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">parameters</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">:</span>
            <span class="n">population_values</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">parameter_names</span><span class="p">,</span> <span class="n">gather</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">arr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">parameter_names</span><span class="p">,</span> <span class="n">population_values</span><span class="p">):</span>
                <span class="n">parameters</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value_list</span> <span class="ow">in</span> <span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">parameters</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">value_list</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">simplify</span><span class="p">:</span>
                <span class="n">parameters</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">simplify_parameter_array</span><span class="p">(</span><span class="n">parameters</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">parameters</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">parameter_names</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">return_list</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">parameter_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Assembly.set"><a class="viewcode-back" href="../../../reference/populations.html#pyNN.neuron.Assembly.set">[docs]</a>    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">parameters</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set one or more parameters for every cell in the Assembly.</span>

<span class="sd">        Values passed to set() may be:</span>
<span class="sd">            (1) single values</span>
<span class="sd">            (2) RandomDistribution objects</span>
<span class="sd">            (3) mapping functions, where a mapping function accepts a single</span>
<span class="sd">                argument (the cell index) and returns a single value.</span>

<span class="sd">        Here, a &quot;single value&quot; may be either a single number or a list/array of</span>
<span class="sd">        numbers (e.g. for spike times).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="o">**</span><span class="n">parameters</span><span class="p">)</span></div>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;set(parametername=rand_distr)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">rset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parametername</span><span class="p">,</span> <span class="n">rand_distr</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">parametername</span><span class="o">=</span><span class="n">rand_distr</span><span class="p">)</span>

<div class="viewcode-block" id="Assembly.record"><a class="viewcode-back" href="../../../reference/populations.html#pyNN.neuron.Assembly.record">[docs]</a>    <span class="k">def</span> <span class="nf">record</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">to_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sampling_interval</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Record the specified variable or variables for all cells in the Assembly.</span>

<span class="sd">        `variables` may be either a single variable name or a list of variable</span>
<span class="sd">        names. For a given celltype class, `celltype.recordable` contains a list of</span>
<span class="sd">        variables that can be recorded for that celltype.</span>

<span class="sd">        If specified, `to_file` should be either a filename or a Neo IO instance and `write_data()`</span>
<span class="sd">        will be automatically called when `end()` is called.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">to_file</span><span class="p">,</span> <span class="n">sampling_interval</span><span class="p">)</span></div>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;record(&#39;v&#39;)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">record_v</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_file</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Record the membrane potential from all cells in the Assembly.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="n">to_file</span><span class="p">)</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;record([&#39;gsyn_exc&#39;, &#39;gsyn_inh&#39;])&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">record_gsyn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_file</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Record synaptic conductances from all cells in the Assembly.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="p">([</span><span class="s1">&#39;gsyn_exc&#39;</span><span class="p">,</span> <span class="s1">&#39;gsyn_inh&#39;</span><span class="p">],</span> <span class="n">to_file</span><span class="p">)</span>

<div class="viewcode-block" id="Assembly.get_population"><a class="viewcode-back" href="../../../reference/populations.html#pyNN.neuron.Assembly.get_population">[docs]</a>    <span class="k">def</span> <span class="nf">get_population</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the Population/PopulationView from within the Assembly that has</span>
<span class="sd">        the given label. If no such Population exists, raise KeyError.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="n">p</span><span class="o">.</span><span class="n">label</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">p</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Assembly does not contain a population with the label </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">label</span><span class="p">)</span></div>

<div class="viewcode-block" id="Assembly.save_positions"><a class="viewcode-back" href="../../../reference/populations.html#pyNN.neuron.Assembly.save_positions">[docs]</a>    <span class="k">def</span> <span class="nf">save_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save positions to file. The output format is id x y z</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="n">file</span> <span class="o">=</span> <span class="n">files</span><span class="o">.</span><span class="n">StandardTextFile</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_cells</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">cells</span><span class="p">),</span> <span class="mi">4</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">id_to_index</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">])</span>
        <span class="n">result</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">T</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simulator</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">mpi_rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;assembly&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">})</span>
            <span class="n">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">position_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">gen</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">gen</span>

<div class="viewcode-block" id="Assembly.get_data"><a class="viewcode-back" href="../../../reference/populations.html#pyNN.neuron.Assembly.get_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">gather</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">clear</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">annotations</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a Neo `Block` containing the data (spikes, state variables)</span>
<span class="sd">        recorded from the Assembly.</span>

<span class="sd">        `variables` - either a single variable name or a list of variable names</span>
<span class="sd">                      Variables must have been previously recorded, otherwise an</span>
<span class="sd">                      Exception will be raised.</span>

<span class="sd">        For parallel simulators, if `gather` is True, all data will be gathered</span>
<span class="sd">        to all nodes and the Neo `Block` will contain data from all nodes.</span>
<span class="sd">        Otherwise, the Neo `Block` will contain only data from the cells</span>
<span class="sd">        simulated on the local node.</span>

<span class="sd">        If `clear` is True, recorded data will be deleted from the `Assembly`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span>
        <span class="n">description</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span>
        <span class="n">blocks</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">gather</span><span class="p">,</span> <span class="n">clear</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">]</span>
        <span class="c1"># adjust channel_ids to match assembly channel indices</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">blocks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">segments</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">signal_array</span> <span class="ow">in</span> <span class="n">segment</span><span class="o">.</span><span class="n">analogsignals</span><span class="p">:</span>
                    <span class="n">signal_array</span><span class="o">.</span><span class="n">channel_index</span><span class="o">.</span><span class="n">channel_ids</span> <span class="o">+=</span> <span class="n">offset</span>
            <span class="n">offset</span> <span class="o">+=</span> <span class="n">p</span><span class="o">.</span><span class="n">size</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">block</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">blocks</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">block</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">segment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">segments</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;  </span><span class="si">%d</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">segment</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">segment</span><span class="o">.</span><span class="n">analogsignals</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;    </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">merged_block</span> <span class="o">=</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">merged_block</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
        <span class="n">merged_block</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="n">merged_block</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="n">description</span>
        <span class="k">if</span> <span class="n">annotations</span><span class="p">:</span>
            <span class="n">merged_block</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="o">**</span><span class="n">annotations</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">merged_block</span></div>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;get_data(&#39;spikes&#39;)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">getSpikes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gather</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">compatible_output</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="s1">&#39;spikes&#39;</span><span class="p">,</span> <span class="n">gather</span><span class="p">)</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;get_data(&#39;v&#39;)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_v</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gather</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">compatible_output</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="n">gather</span><span class="p">)</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;get_data([&#39;gsyn_exc&#39;, &#39;gsyn_inh&#39;])&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_gsyn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gather</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">compatible_output</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">([</span><span class="s1">&#39;gsyn_exc&#39;</span><span class="p">,</span> <span class="s1">&#39;gsyn_inh&#39;</span><span class="p">],</span> <span class="n">gather</span><span class="p">)</span>

<div class="viewcode-block" id="Assembly.mean_spike_count"><a class="viewcode-back" href="../../../reference/populations.html#pyNN.neuron.Assembly.mean_spike_count">[docs]</a>    <span class="k">def</span> <span class="nf">mean_spike_count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gather</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the mean number of spikes per neuron.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spike_counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spike_counts</span><span class="p">()</span>
        <span class="n">total_spikes</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">spike_counts</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simulator</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">mpi_rank</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">gather</span><span class="p">:</span>  <span class="c1"># should maybe use allgather, and get the numbers on all nodes</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">total_spikes</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">spike_counts</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span></div>

<div class="viewcode-block" id="Assembly.get_spike_counts"><a class="viewcode-back" href="../../../reference/populations.html#pyNN.neuron.Assembly.get_spike_counts">[docs]</a>    <span class="k">def</span> <span class="nf">get_spike_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gather</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of spikes for each neuron.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">spike_counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">recorder</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;spikes&#39;</span><span class="p">,</span> <span class="n">gather</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_record_filter</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">errors</span><span class="o">.</span><span class="n">NothingToWriteError</span><span class="p">:</span>
            <span class="n">spike_counts</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">spike_counts</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">recorder</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;spikes&#39;</span><span class="p">,</span> <span class="n">gather</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">_record_filter</span><span class="p">))</span>
            <span class="k">except</span> <span class="n">errors</span><span class="o">.</span><span class="n">NothingToWriteError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="n">spike_counts</span></div>

<div class="viewcode-block" id="Assembly.write_data"><a class="viewcode-back" href="../../../reference/populations.html#pyNN.neuron.Assembly.write_data">[docs]</a>    <span class="k">def</span> <span class="nf">write_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">io</span><span class="p">,</span> <span class="n">variables</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">gather</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">clear</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">annotations</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write recorded data to file, using one of the file formats supported by</span>
<span class="sd">        Neo.</span>

<span class="sd">        `io`:</span>
<span class="sd">            a Neo IO instance</span>
<span class="sd">        `variables`:</span>
<span class="sd">            either a single variable name or a list of variable names.</span>
<span class="sd">            Variables must have been previously recorded, otherwise an</span>
<span class="sd">            Exception will be raised.</span>

<span class="sd">        For parallel simulators, if `gather` is True, all data will be gathered</span>
<span class="sd">        to the master node and a single output file created there. Otherwise, a</span>
<span class="sd">        file will be written on each node, containing only data from the cells</span>
<span class="sd">        simulated on that node.</span>

<span class="sd">        If `clear` is True, recorded data will be deleted from the `Population`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="n">io</span> <span class="o">=</span> <span class="n">recording</span><span class="o">.</span><span class="n">get_io</span><span class="p">(</span><span class="n">io</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gather</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simulator</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">num_processes</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">io</span><span class="o">.</span><span class="n">filename</span> <span class="o">+=</span> <span class="s1">&#39;.</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simulator</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">mpi_rank</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Recorder is writing &#39;</span><span class="si">%s</span><span class="s2">&#39; to file &#39;</span><span class="si">%s</span><span class="s2">&#39; with gather=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                                               <span class="n">variables</span><span class="p">,</span> <span class="n">io</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">gather</span><span class="p">))</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">gather</span><span class="p">,</span> <span class="n">clear</span><span class="p">,</span> <span class="n">annotations</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simulator</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">mpi_rank</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">gather</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Writing data to file </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">io</span><span class="p">)</span>
            <span class="n">io</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;write_data(file, &#39;spikes&#39;)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">printSpikes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">gather</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">compatible_output</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write_data</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s1">&#39;spikes&#39;</span><span class="p">,</span> <span class="n">gather</span><span class="p">)</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;write_data(file, &#39;v&#39;)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">print_v</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">gather</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">compatible_output</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write_data</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="n">gather</span><span class="p">)</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;write_data([&#39;gsyn_exc&#39;, &#39;gsyn_inh&#39;])&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">print_gsyn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">gather</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">compatible_output</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write_data</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;gsyn_exc&#39;</span><span class="p">,</span> <span class="s1">&#39;gsyn_inh&#39;</span><span class="p">],</span> <span class="n">gather</span><span class="p">)</span>

<div class="viewcode-block" id="Assembly.inject"><a class="viewcode-back" href="../../../reference/populations.html#pyNN.neuron.Assembly.inject">[docs]</a>    <span class="k">def</span> <span class="nf">inject</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_source</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Connect a current source to all cells in the Assembly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">:</span>
            <span class="n">current_source</span><span class="o">.</span><span class="n">inject_into</span><span class="p">(</span><span class="n">p</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">injectable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">injectable</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">)</span>

<div class="viewcode-block" id="Assembly.describe"><a class="viewcode-back" href="../../../reference/populations.html#pyNN.neuron.Assembly.describe">[docs]</a>    <span class="k">def</span> <span class="nf">describe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">template</span><span class="o">=</span><span class="s1">&#39;assembly_default.txt&#39;</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a human-readable description of the assembly.</span>

<span class="sd">        The output may be customized by specifying a different template</span>
<span class="sd">        togther with an associated template engine (see ``pyNN.descriptions``).</span>

<span class="sd">        If template is None, then a dictionary containing the template context</span>
<span class="sd">        will be returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">context</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span>
                   <span class="s2">&quot;populations&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">describe</span><span class="p">(</span><span class="n">template</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">]}</span>
        <span class="k">return</span> <span class="n">descriptions</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span></div>

<div class="viewcode-block" id="Assembly.get_annotations"><a class="viewcode-back" href="../../../reference/populations.html#pyNN.neuron.Assembly.get_annotations">[docs]</a>    <span class="k">def</span> <span class="nf">get_annotations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annotation_keys</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the values of the given annotations for each population in the Assembly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">annotation_keys</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="n">annotation_keys</span> <span class="o">=</span> <span class="p">(</span><span class="n">annotation_keys</span><span class="p">,)</span>
        <span class="n">annotations</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">annotation_keys</span><span class="p">:</span>
            <span class="n">is_array_annotation</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">:</span>
                <span class="n">annotation</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">annotations</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="n">annotations</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">annotation</span><span class="p">)</span>
                <span class="n">is_array_annotation</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">annotation</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_array_annotation</span><span class="p">:</span>
                <span class="n">annotations</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">annotations</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">simplify</span><span class="p">:</span>
                <span class="n">annotations</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">simplify_parameter_array</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">annotations</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">annotations</span></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/pyNN_logo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">PyNN 0.9.6 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">pyNN.common.populations</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2006-2020, the PyNN community.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.0.
    </div>
  </body>
</html>